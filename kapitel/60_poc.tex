\chapter{Implementierung des Proof-of-Concepts}

Im Verlaufe des Projekts wurde das Datenmodell mitsamt der Hexagonalen Architektur und allen relevanten Anwendungsfällen in einem Proof-of-Concept implementiert. Das Ziel dieser Software ist die Unterstreichung einer möglichen praktischen Umsetzung der Businessanforderungen unter Anwendung der gewonnen Erkenntnisse. 

Nach dem Aufsetzen eines neuen Projektes, welches benötigte Frameworks und Abhängigkeiten importiert, um \gls{Boilerplate}-Code weitestgehend zu vermeiden, wurde die Software mithilfe von Kotlin entwickelt und Komponente analog zu einer Hexagonalen Architektur in die drei Bereiche primäre Adapter, Applikationskern und sekundäre Adapter aufgeteilt. Innerhalb des Applikationskerns befindet sich jegliche Businesslogik, sowie die notwendigen Applicationservices, Domainservices und das Domainmodell entsprechend des Domain-Driven Designs. Die umgesetzten Aggregationsschnitte belaufen sich auf die Variante A und D, sowie ihren Abwandlungen. Dieses Kapitel geht auf die Entwicklung des ersteren Ansatzes mit einem einzelnen, großen Basket-Aggregate tiefer ein.

\comment{Bild der konkreten Architektur eventuell sinnvoll, aber keine übersichtliche Darstellungsmethode gefunden...}

\section{Design der primären Adapter}

Primäre Adapter sind Komponente, welche den Datenfluss aufgrund von einem Signal eines externen Systems initiieren. Sie stellen die grundlegenden Kommunikationsschnittstellen zwischen Clients und der Software dar. Im Proof-of-Concept fallen in diesen Bereich hauptsächlich die sogenannten Controller, welche für den Empfang von REST-API-Anfragen, der Deserialisierung übergebener Daten, sowie der Serialisierung des Antwortinhaltes zuständig sind. Zu Beginn jedes Anwendungsfalles wird ein Controller durch den Touchpoint angesprochen. Der jeweils zuständige Adapter wird aus einem Zusammenschluss von aufgerufener URL und HTTP-Methode bestimmt. 

Ein Controller beinhaltet lediglich Logik für den Empfang von Daten und der Formulierung zugehöriger Antworten. Alle Informationen, welche von außen stammen, müssen vor der Weitergabe an den Applikationskern in einen Teil des Domainmodell umgewandelt werden. Ist dies nicht der Fall, hält der zentrale Teil der Software eine Abhängigkeit nach außen und das \acrlong{DIP} wird verletzt. Der Einsatz von sogenannten \acrlong{DTO}s (\acrshort{DTO}) ist gestattet, sofern diese in einem Modul des Applikationskern liegen, sodass dieser volle Kontrolle über ihre Struktur besitzt. Ein konkretes Beispiel für einen Controller ist im Codebeispiel \ref{lst:controller} abgebildet. Zur Implementierung dieser Funktionalität wurde das Framework 'Ktor' verwendet.

\begin{minipage}{\linewidth} % No pagebreak inside a minipage
\begin{lstlisting}[caption={Beispiel eines Controllers zum aktualiseren von Kundendaten}, label={lst:controller}, language=Kotlin]
put("/basket/{id}/customer") { 
	variable basketId = parseIdFromUrl("{id}")
	variable customer = request.body<Customer>()  
	variable basket = basketApiPort.setCustomer(basketId, customer)
	request.respond(HttpStatusCode.OK, basket)
}
\end{lstlisting}
\end{minipage}

\begin{itemize}[noitemsep,nolistsep]
	\item Zeile 1: Definiert die HTTP-Methode als 'PUT' und das Format der URL für diesen Endpunkt
	\item Zeile 2: Auslesen der BasketId aus der URL als Pfadparameters 
	\item Zeile 3: Deserialisierung der übertragenen Daten zu einem Customer-Objekt
	\item Zeile 4: Weitergabe der Objekte an den zuständigen Applicationservice über ein Interface
	\item Zeile 5: Antwort an die Anfrage mit HTTP-Status '200' und den geänderten Basket
\end{itemize}

Für jeden definierten Anwendungsfall ist ein entsprechender Port und Controller zuständig. Die tatsächliche Implementierung der Schnittstelle wird mittels \Gls{DI} durch das Framework 'Koin' bestimmt und geladen. Dadurch bleiben Abhängigkeiten jederzeit austauschbar und unabhängig testbar. Beispielsweise kann die korrekte Funktionsweise eines Controllers überprüft werden, indem der Applicationservice durch ein Test-Objekt ausgetauscht und Aufrufe des Objektes ausschließlich simuliert werden. Somit erfahren die einzelnen Komponenten in Testfällen keine Beeinflussung durch eventuell inkorrekt implementierten Code anderer Klassen und Test-Fehlschläge können eindeutig einem bestimmten Abschnitt der Software zugeschrieben werden.

\section{Realisierung des Applikationskerns}

Der Applikationskern stellt das Herz der Anwendung dar. Das maßgebliche Ziel einer Hexagonalen Architektur ist es, dass Zentrum komplett von äußeren Modulen zu entkoppelt. Somit können Adapter jederzeit ausgetauscht werden, ohne hierbei die Businesslogik anpassen zu müssen. Die Kommunikation mit dem Kern geschieht ausschließlich über Interfaces, den Ports.

\subsection{Definition von Applicationservices anhand ihrer Aufgaben}

Entsprechend der Definition im Domain-Driven Design liegen Applicationservices eine logische Ebene höher als die Domainservice. Der Unterschied zwischen den beiden ist ihre Einsichten in die Domain. Ein Applicationservice darf kein direktes Domainwissen verwirklichen. Dazu zählen Invarianten oder die Umsetzung von Businessanforderungen.
Meist beinhalten diese Service folgende Anweisungen:

\begin{itemize}[noitemsep,nolistsep]
	\item Starten und schließen einer Transaktion
	\item Laden von Aggregates aus Repositories
	\item Einfache Ablaufsteuerung
	\item Aufruf von Aggregate- oder Domainservice-Funktionen
	\item Umsetzung von technologischen Komponenten wie Event-Listener oder Caching
\end{itemize}

Ein simples Beispiel bietet uns der Basket-Item-Applicationservice. Dieser wird aufgerufen, sofern Änderungen an den Items durchgeführt werden sollen. Der in Figur \ref{lst:applicationservice} dargestellte Code behandelt die Entfernung eines Basket-Items.

\begin{minipage}{\linewidth} % No pagebreak inside a minipage
	\begin{lstlisting}[caption={Eine Beispielsfunktion des BasketItem-Applikationservice}, label={lst:applicationservice}, language=Kotlin]
function removeBasketItem(BasketId basketId, BasketItemId basketItemId) {
	variable basket = basketRepository.findById(basketId)
	basket.removeBasketItem(basketItemId)
	basketStorageService.store(basket)
}
	\end{lstlisting}
\end{minipage}

\begin{itemize}[noitemsep,nolistsep]
	\item Zeile 2: Laden eines Baskets anhand seiner Id durch ein Repository. 
	\item Zeile 3: Aufruf des Basket-Aggregate-Root zum Entfernen des übergebenen Items. Innerhalb dieser Funktion werden zusätzlich Aufgaben erledigt, wie das Neuberechnen des Gesamtpreises. Sollte die Kalkulation zu komplex ausfallen, kann hier ein Berechnungsservice als Parameter übergeben werden, sodass der Basket für seine eigene Konsistenz verantwortlich ist. 
	\item Zeile 4: Speichern des Baskets mit den abgeänderten Daten.
\end{itemize}

\subsection{Aufteilen der Businesslogik zwischen Domainservices und Datenmodell}

Aufgrund der Tatsache, dass die Software lediglich ein Aggregat und somit auch nur ein Aggregate-Root besitzt, müssen alle Operationen auf den Attributen des Baskets durch eine Methode im Basket selbst geschehen. Anwendungsfälle, die es erfordern tiefer gelegene Objekte anzupassen, werden durch eine Kette von Funktionsaufrufen umgesetzt. Hierbei können alle notwendigen Invarianten überprüft werden, da das komplette Datenmodell geladen ist. Zur Trennung der Datenhaltung von den Funktionalitäten implementiert der Basket ein Interface, welches jegliche von außen notwendigen Schnittstellen beinhaltet. Dadurch kann das darunterliegende Datenmodell ausgetauscht oder in Tests simuliert werden. Als Veranschaulichung für das Abändern der Fulfillment Methode dient der Codeauszug \ref{lst:basket}.

\begin{minipage}{\linewidth} % No pagebreak inside a minipage
	\begin{lstlisting}[caption={Setzen der Fulfillment Methode im Basket Aggregate}, label={lst:basket}, language=Kotlin]
function setFulfillment(Fulfillment fulfillment, FulfillmentPort fulfillmentPort) {
	validateIfModificationIsAllowed()
	variable availableFulfillment = fulfillmentPort.getAvailableFulfillment(outletId)
	throwIf(availableFulfillment.doesNotContain(fulfillment)) {
		IllegalModificationError("$fulfillment is not avaiable")
	}
	this.fulfillment = fulfillment
}
	\end{lstlisting}
\end{minipage}

\begin{itemize}[noitemsep,nolistsep]
	\item Zeile 2: Überprüfung, ob der Basket aktuell Änderungen zulässt anhand des Status. Stellt eine Invariante des Datenmodells dar.
	\item Zeile 3: Laden aller verfügbarer Fulfillment Methoden für diesen Basket durch einen sekundären Adapter. Die Kommunikation mit dem Adapter erfolgt über einen Port.
	\item Zeile 4-6: Falls der neue Wert nicht unter den verfügbaren Fulfillment ist, wird der Aufruf zurückgewiesen und eine entsprechende Fehlermeldung an den Client durch den Controller geliefert.
	\item Zeile 7: Überschreiben des alten Wertes. Dieser Punkt wird nicht erreicht, wenn zuvor eine Businessanforderung gescheitert ist.
\end{itemize}

Aufgaben, welche nicht direkt einem Objekt zugewiesen werden können oder mehrere Aggregates betreffen sind in Domainservices zu implementieren. Diese liegen auf der gleichen konzeptionellen Ebene wie das Datenmodell und dürfen Businesslogik enthalten. Beispielsweise existiert im Proof-of-Concept ein Domainservice für die Abwicklung des Bezahlverfahren, wie in Code-Ausschnitt \ref{lst:domainservice} aufgeführt. 

\comment{Weglassen des Codebeispiels?}

\begin{minipage}{\linewidth} % No pagebreak inside a minipage
	\begin{lstlisting}[caption={Ausführung des Bezahlvorgangs in einem Domainservice}, label={lst:domainservice}, language=Kotlin]
function executePaymentProcessAndFinalizeBasket(BasketId basketId) {
	variable basket = basketRepository.findById(basketId)
	throwIf(basket.isNotFrozen() or basket.paymentIsNotInitialized()) {
		IllegalModificationError("cannot cancel payment process")
	}
	variable externalPaymentRef = basket.getExternalPaymentRef()
	paymentPort.executePayment(externalPaymentRef)
	basket.executePayments() and basket.finalize()
	basketStorageService.store(basket)
	createOrderAfterFinalization(basket)
}
	\end{lstlisting}
\end{minipage}

\begin{itemize}[noitemsep,nolistsep]
	\item Zeile 2: Laden des aktualisierten Baskets aus dem Repository.
	\item Zeile 3-5: Weist die Durchführung zurück, sofern der Basket sich nicht in den erwarteten Zustand befindet. Dies kann auftreten, wenn die REST-API aufgerufen worden ist, ohne dass ein Zahlungsprozess zuvor gestartet wurde.
	\item Zeile 6-8: Durchführung des Bezahlvorgangs. Die erforderliche Aufrufreihenfolge stellt einen Teil des Domainwissens dar und begründet die Zuteilung der Klasse in die Gruppe der Domainservices.
	\item Zeile 9: Speichern des angepassten Baskets.
	\item Zeile 10: Erstellen eines Bestellvorgangs durch einen separaten Domainservice.
\end{itemize}

\section{Anbinden externer Systeme und Datenbanken durch sekundäre Adapter}

Das, in der Planungsphase erstellte, Context-Diagramm \ref{fig:ContextDiagramm} zeigt verschiedenste Systeme mit denen die Anwendung zum Erfüllen ihrer Aufgaben kommunizieren muss. Für diesen Zweck wurden zwei Gruppen von Komponente eingeführt. Die Service, welche Aufrufe von externen API-Schnittstellen simulieren, und die sekundären Adapter. Letztere implementieren ein vom Applikationskern definiertes Interface, damit eine Brücke zwischen dem Domainkern und den APIs der Nachbarsysteme gewährleistet ist. Analog zu den primären Adaptern, existieren im Anwendungskern keine direkten Abhängigkeiten zu diesem Teil der Software.

Ein Spezialfall sind hierbei die Service für das Erfragen der aktuellen Preis- bzw. Artikelinformationen. Aufgrund von Performance-Verbesserungen wurde zusätzlich eine Abwandlung der Adapter mit Caching-Funktion erstellt. Der normal fungierende Service ruft den zugehörigen API-Service auf, wohingegen der Caching-Adapter zuerst den Preis bzw. Artikel aus dem Cache lädt und zurückgibt, sofern dieser noch als aktuell markiert ist. Sollte der Eintrag veraltet sein, wird der eigentliche Adapter angesprochen, um die zum jetzigen Zeitpunkt validen Daten aus dem externen System zu erfragen. Im Beispiel \ref{lst:adapter} ist die, für das Aktualisieren des Preises zuständige, Klasse  abgebildet.

\begin{minipage}{\linewidth} % No pagebreak inside a minipage
	\begin{lstlisting}[caption={Preisadapter mit Caching-Funktion}, label={lst:adapter}, language=Kotlin]
class CachedPriceAdapter {
	
	variable PriceRepository priceRepository 
	variable PriceAdapter priceAdapter
	
	function fetchPrice(PriceId priceId) returns Price {
		return priceRepository.getAndUpdateIfInvalid(priceId, fallback = {
			priceAdapter.fetchPrice(priceId)
		})
	}
}
	\end{lstlisting}
\end{minipage}

\begin{itemize}[noitemsep,nolistsep]
	\item Zeile 3-4: Der Cache-Preisadapter hat eine Abhängigkeit zum normalen Preisadapter und zu einem Repository zum Abrufen des zwischengespeicherten Preises
	\item Zeile 7: Abfragen des Preises aus dem Cache-Repository. Sollte der Preis invalide sein wird Zeile 8 ausgeführt.
	\item Zeile 8: Weiterleitung der Anfrage an den zuständigen Adapter, welcher das externe System aufruft. Das Ergebnis wird mit einem aktuellen Zeitstempel im Cache abgelegt.
\end{itemize}

Zusätzlich zu diesen Adaptern gehören ebenfalls die Repositories in diesem Bereich der Hexagonalen Architektur. Sie managen den Zugriff auf die Datenbank und alle Funktionalitäten, welche in dieses Aufgabengebiet fallen. In dem Proof-of-Concept wird das gesamte Basket-Aggregate abgespeichert. Aus diesem Grund wird nur ein Repository benötigt, welches eine grundlegende Suchfunktion mithilfe der BasketId und eine Speicherfunktion anbietet. Abgesehen davon gehören noch die zwei Caching-Repositories zu dieser Gruppe. 