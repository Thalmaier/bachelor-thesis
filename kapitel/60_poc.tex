\chapter{Implementierung des Proof-of-Concepts}

Im Verlaufe des Projekts wurde das Datenmodell mitsamt der Hexagonalen Architektur und allen relevanten Anwendungsfällen in einem Proof-of-Concept implementiert. Das Ziel dieser Software ist die Unterstreichung einer möglichen praktischen Umsetzung der Businessanforderungen unter Anwendung der gewonnenen Erkenntnisse. 

Zu Beginn wurde das Projekt mit benötigten Frameworks und Abhängigkeiten aufgesetzt, um \gls{Boilerplate-Code} weitestgehend zu vermeiden. Die Software wurde mithilfe von Kotlin entwickelt. Die Komponenten sind analog zu einer Hexagonalen Architektur aufgeteilt in primäre Adapter, Applikationskern und sekundäre Adapter. Innerhalb des Applikationskerns befindet sich jegliche Businesslogik, sowie die notwendigen Applicationservices, Domainservices und das Domainmodell entsprechend des Domain-Driven Designs. Die umgesetzten Aggregationsschnitte belaufen sich auf die Variante A und D, sowie ihren Abwandlungen. Dieses Kapitel geht auf die Entwicklung des ersteren Ansatzes mit einem einzelnen, großen Basket-Aggregate tiefer ein.

\section{Design der primären Adapter}

Primäre Adapter sind die grundlegenden Kommunikationsschnittstellen zwischen Clients und der Software, welche den Datenfluss anhand eines externen Signals initiieren. Im Proof-of-Concept fallen in diesen Bereich hauptsächlich die sogenannten Controller, welche für den Empfang von REST-API-Anfragen, die Deserialisierung übergebener Daten, sowie die Serialisierung des Antwortinhaltes zuständig sind. Zu Beginn jedes Anwendungsfalles wird ein Controller durch den Touchpoint angesprochen. Der jeweils zuständige Adapter wird aus dem Zusammenschluss der aufgerufenen URL und HTTP-Methode bestimmt. Ein Controller beinhaltet lediglich Logik für den Empfang von Daten und der Formulierung zugehöriger Antworten. Alle externen Informationen müssen vor der Weitergabe an den Applikationskern in ein Objekt des Domainmodells umgewandelt werden. Ist dies nicht der Fall, erhält der zentrale Teil der Software eine Abhängigkeit nach außen und das \acrlong{DIP} wird verletzt. Ein konkreter Controller ist im Codebeispiel \ref{lst:controller} abgebildet. Zur Implementierung dieser Funktionalitäten wurde das Framework 'Ktor' eingesetzt.

\vspace{0.5cm}
\begin{minipage}{\linewidth} % No pagebreak inside a minipage
\begin{lstlisting}[caption={Beispiel eines Controllers zum Aktualisieren von Kundendaten}, label={lst:controller}, language=Kotlin]
put("/basket/{id}/customer") {
	variable basketID = parseParameterFromUrl("id")
	variable customer = request.parseBody<Customer>() 
	
	variable basket = basketApiPort.setCustomer(basketID, customer)
	
	request.respond(HttpStatusCode.OK, basket)
}
\end{lstlisting}

\begin{itemize}
	\setlength\itemsep{-1pt}
	\item Zeile 1: Definiert die HTTP-Methode als 'PUT' und das Format der URL für diesen Endpunkt
	\item Zeile 2: Auslesen der BasketID aus der URL als Pfadparameter
	\item Zeile 3: Deserialisierung der übertragenen Daten zu einem Customer-Objekt
	\item Zeile 5: Weitergabe der Parameter an den zuständigen Applicationservice mithilfe eines Ports
	\item Zeile 7: Antwort an die Anfrage mit HTTP-Status '200' und den geänderten Basket
\end{itemize}
\end{minipage}

\pagebreak

Für jeden definierten Anwendungsfall ist ein entsprechender Port und Controller zuständig. Die tatsächliche Implementierung der Schnittstelle wird mittels \Gls{DI} durch das Framework 'Koin' geladen. Dadurch bleiben Abhängigkeiten jederzeit austauschbar und unabhängig testbar. Beispielsweise kann die korrekte Funktionsweise eines Controllers überprüft werden, indem der Applicationservice durch ein Test-Objekt ausgetauscht und Aufrufe des Objektes ausschließlich simuliert werden. Somit erfahren die einzelnen Komponenten in Testfällen keine Beeinflussung durch eventuell inkorrekt implementierten Code anderer Klassen und Test-Fehlschläge können eindeutig einem bestimmten Abschnitt der Software zugeschrieben werden. \cite{DI_2007, Lindooren.2007}

\section{Realisierung des Applikationskerns}

Der Applikationskern stellt das Herz der Anwendung dar. Das Ziel einer Hexagonalen Architektur ist es, das Zentrum komplett von äußeren Modulen zu entkoppeln \cite{Cockburn.Hexagonal}. In Domain-Driven Design liegen die Applicationservices, Domainservices und das Datenmodell im Inneren des Applikationskerns \cite[S. 125ff.]{Vernon.2015}. 

\subsection{Applicationservices}

Ein simples Beispiel für einen implementierten Applicationservice bietet uns der Basket-Item-Applicationservice, welcher bei Änderungen an den Items angesprochen wird. Der in Figur \ref{lst:applicationservice} dargestellte Code behandelt die Entfernung eines Basket-Items. Hierbei wird keine Businesslogik im Service verankert, lediglich das Transaktionsmanagement und die Ablaufsteuerung der Funktionsaufrufe von Aggregates bzw. Domainservices.

\vspace{0.5cm}
\begin{minipage}{\linewidth} % No pagebreak inside a minipage
	\begin{lstlisting}[caption={Funktion zum Entfernen von Basket-Items in einem Applicationservice}, label={lst:applicationservice}, language=Kotlin]
function removeBasketItem(BasketID basketID, BasketItemID basketItemID) {
	transaction {
		variable basket = basketRepository.findByID(basketID)
		basket.removeBasketItem(basketItemID)
		basketStorageService.store(basket)
	}
}
	\end{lstlisting}

	\begin{itemize}
		\setlength\itemsep{-1pt}
		\item Zeile 2: Starten einer Transaktion über die Zeilen 3 bis 5.
		\item Zeile 3: Laden eines Baskets anhand seiner ID durch ein Repository. 
		\item Zeile 4: Aufruf einer Funktion des Aggregate Roots zum Entfernen des übergebenen Items. Innerhalb dieser Funktion werden zusätzlich Aufgaben erledigt, wie das Neuberechnen des Gesamtpreises. Sollte die Kalkulation zu komplex ausfallen, kann ein Berechnungsservice als Parameter übergeben werden, sodass der Basket weiter für seine eigene Konsistenz verantwortlich ist. 
		\item Zeile 5: Speichern des Baskets mit den abgeänderten Daten.
	\end{itemize}
\end{minipage}

\pagebreak

\subsection{Basket-Aggregate}

Damit der Basket für seine eigene Konsistenz zuständig sein kann, müssen jegliche Änderungen durch eine Methode im Aggregate selbst geschehen. Anwendungsfälle, die es erfordern tiefer gelegene Objekte anzupassen, werden durch eine Kette von Funktionsaufrufen umgesetzt. Zur Trennung der Datenhaltung von den Funktionalitäten implementiert der Basket ein Interface. Dadurch kann das darunterliegende Datenmodell ausgetauscht oder in Tests simuliert werden. Der Codeauszug \ref{lst:basket} veranschaulicht das Abändern der Fulfillment Methode innerhalb des Baskets.

\vspace{0.5cm}
\begin{minipage}{\linewidth} % No pagebreak inside a minipage
	\begin{lstlisting}[caption={Setzen der Fulfillment Methode im Basket Aggregate}, label={lst:basket}, language=Kotlin]
function setFulfillment(Fulfillment fulfillment, FulfillmentPort fulfillmentPort) {
	validateIfModificationIsAllowed()
	
	variable availableFulfillment = fulfillmentPort.getAvailableFulfillment(outletID)
	
	throwIf(availableFulfillment.doesNotContain(fulfillment)) {
		IllegalModificationError("$fulfillment is not avaiable")
	}

	this.fulfillment = fulfillment
}
	\end{lstlisting}


	\begin{itemize}
		\setlength\itemsep{-1pt}
		\item Zeile 2: Überprüfung der Invariante, ob der Basket anhand seines Status aktuell Änderungen zulässt.
		\item Zeile 4: Laden aller verfügbarer Fulfillment Methoden für diesen Basket durch einen sekundären Adapter. Die Kommunikation mit dem Adapter erfolgt über einen Port.
		\item Zeile 6-8: Falls der neue Wert nicht unter den verfügbaren Fulfillments ist, wird der Aufruf zurückgewiesen und eine entsprechende Fehlermeldung an den Client durch den Controller geliefert.
		\item Zeile 10: Überschreiben des alten Wertes. Dieser Punkt wird nicht erreicht, wenn zuvor eine Businessanforderung gescheitert ist.
	\end{itemize}
\end{minipage}

\pagebreak

\subsection{Domainservices}

Aufgaben, welche nicht direkt einem Objekt zugewiesen werden können oder mehrere Aggregates betreffen sind in Domainservices zu implementieren \cite[S. 267]{Vernon.2015}. Beispielsweise wurde im Proof-of-Concept aus Gründen der Übersichtlichkeit und Kohäsion die Abwicklung des Bezahlverfahren aus dem Basket herausgetrennt und in einem Domainservice implementiert. In Code-Ausschnitt \ref{lst:domainservice} ist die Ausführung des Bezahlvorgangs abgebildet. 

\vspace{0.5cm}
\begin{minipage}{\linewidth} % No pagebreak inside a minipage
	\begin{lstlisting}[caption={Ausführung des Bezahlvorgangs in einem Domainservice}, label={lst:domainservice}, language=Kotlin]
function executePaymentProcessAndFinalizeBasket(BasketID basketID) {
	variable basket = basketRepository.findByID(basketID)
	
	throwIf(basket.isNotFrozen() or basket.paymentIsNotInitialized()) {
		IllegalModificationError("cannot cancel payment process")
	}

	variable externalPaymentRef = basket.getExternalPaymentRef()
	paymentPort.executePayment(externalPaymentRef)
	basket.executePayments() and basket.finalize()
	basketStorageService.store(basket)
	createOrderAfterFinalization(basket)
}
	\end{lstlisting}
	\begin{itemize}
		\setlength\itemsep{-1pt}
		\item Zeile 2: Laden des Baskets aus dem Repository.
		\item Zeile 4-6: Weist die Durchführung zurück, sofern der Basket sich nicht in dem erwarteten Zustand befindet. Dies kann auftreten, wenn die REST-API aufgerufen worden ist, ohne dass ein Zahlungsprozess zuvor gestartet wurde.
		\item Zeile 8-10: Durchführung des Bezahlvorgangs. Die erforderliche Aufrufreihenfolge stellt einen Teil des Domainwissens dar und begründet die Zuteilung der Klasse in die Gruppe der Domainservices.
		\item Zeile 11: Speichern des angepassten Baskets.
		\item Zeile 12: Erstellen eines Bestellvorgangs durch einen separaten Domainservice.
	\end{itemize}
\end{minipage}

\pagebreak

\section{Anbinden externer Systeme und Datenbanken durch sekundäre Adapter}

Das in der Planungsphase erstellte Context-Diagramm \ref{fig:ContextDiagramm} zeigt verschiedenste Systeme mit denen die Anwendung zum Erfüllen ihrer Aufgaben kommunizieren muss. Für diesen Zweck wurden Services, welche das Aufrufen externen API-Schnittstellen simulieren, erstellt. Damit Brücken zwischen der Domain und diesen Services gewährleistet sind, implementieren die sekundären Adapter ein vom Applikationskern definiertes Interface. Analog zu den primären Adaptern, existieren keine direkten Abhängigkeiten des Anwendungskerns zu dem Teil der Software.

Grundsätzlich wird pro Aggregate ein Repository implementiert. Sie verwalten den Zugriff auf die Datenbank und alle Funktionalitäten, welche in dieses Aufgabengebiet fallen, wie elementare Speicher- und Suchfunktionen. Zusätzlich existieren spezielle Komponenten für das Erfragen der aktuellen Preis- bzw. Artikelinformationen. Aufgrund von Performance-Verbesserungen wurden zusätzliche Abwandlungen der Adapter mit Caching-Funktion erstellt. Der normal fungierende Adapter ruft den zugehörigen API-Service auf, wohingegen der Caching-Adapter den Preis bzw. Artikel aus dem Cache lädt. Falls der Eintrag veraltet ist, wird der eigentliche Adapter angesprochen, um die zum jetzigen Zeitpunkt validen Daten zu erfragen und im Cache abzulegen. Das Beispiel \ref{lst:adapter} stellt die Komponente für das Aktualisieren der Preisinformationen dar. 

\vspace{0,5cm}
\begin{minipage}{\linewidth} % No pagebreak inside a minipage
	\begin{lstlisting}[caption={Preisadapter mit Caching-Funktion}, label={lst:adapter}, language=Kotlin]
class CachedPriceAdapter {
	
	variable PriceCachingRepository priceCachingRepository 
	variable PriceAdapter priceAdapter
	
	function fetchPrice(PriceID priceID) returns Price {
		return priceCachingRepository.getAndUpdateIfInvalid(priceID, fallback = {
			priceAdapter.fetchPrice(priceID)
		})
	}
}
	\end{lstlisting}
	\begin{itemize}
		\setlength\itemsep{-1pt}
		\item Zeile 3-4: Der \emph{CachedPriceAdapter} hat eine Abhängigkeit zum normalen Preisadapter und zu einem Repository zum Abrufen des zwischengespeicherten Preises
		\item Zeile 7: Abfragen des Preises aus dem Caching-Repository. Sollte der Preis invalide sein, weil er beispielsweise veraltet ist, wird Zeile 8 ausgeführt.
		\item Zeile 8: Weiterleitung der Anfrage an den zuständigen Adapter, welcher das externe System aufruft. Das Ergebnis wird mit einem aktuellen Zeitstempel im Cache abgelegt.
	\end{itemize}
\end{minipage}
