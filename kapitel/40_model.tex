
%% PROOF OF CONCEPT %% 

\chapter{Festlegung des Datenmodells durch Domain-Driven Design}

Durch die Schaffung eines grundlegenden Verständnisses für Designprinzipien, Hexagonaler Architektur und Domain-Driven Design kann auf zusätzlicher Basis der vorgehenden Analysen ein Proof-of-Concept der Checkout-Software entwickelt werden. Hierzu wird weiterhin das typische Vorgehen von Domain-Driven Design verfolgt und zunächst der Domainumfang und die Ubiquitous Language definiert, gefolgt vom Erstellen des zentralen Domain-Modells.

\section{Abgrenzung der Domain und Bounded Contexts mithilfe der Planungsphase}

Aufgrund der ausführlichen Vorbereitung wurde die Domain bereits passiv festgelegt und analysiert. Beispielsweise beschreibt das Context-Diagramm \ref{fig:ContextDiagramm} hierbei unsere Domaingrenzen. Eine Domain und die dazugehörigen Subdomains spannen den Problemraum über alle definierten Anwendungsfälle und Businessanforderungen auf. Die Größe der Domain ist entscheidend für die Bestimmung der Subdomains und des Bounded-Contexts. Den Checkout beispielsweise als eine zusammengehörige Domain anzusehen, würde darin resultieren, dass sich entweder nur ein Bounded-Context ergibt oder der Checkout selbst eine weitere Unterteilung erfahren muss. Diese Aufteilung fällt dementsprechend zu klein aus, da grundlegend je Bounded-Context nur maximal ein Team zuständig sein sollte. Folglich kann als nächstmögliche Eingrenzung der Checkout und alle abhängigen Systeme angesehen werden. Zu beachten ist hierbei, sich nicht auf die konkreten Systeme zu fixieren, da sie eher der Lösungsebene zuweisbar sind, sondern logisch naheliegende Aufgaben in eine Gruppe zusammenzufassen. In den Zuständigkeitsbereich der Domain fallen unter anderem Anforderungen an der Abwicklung des Zahlungs- und Bestellprozesses, sowie Bereitstellung von Preis- bzw. Artikelinformationen. Hierfür muss ebenfalls eine Verwaltungsmöglichkeit für diese Daten bereitgestellt werden. Die Abgrenzungen der Bounded-Contexts ist durch die jetzigen Überlegungen und die bereits bestehenden Architektur vorgegeben, wodurch das vorgehende Context-Diagramm \ref{fig:ContextDiagramm} ebenfalls als Context-Map fungieren kann.

\section{Festlegen einer Ubiquitous Language}

In der Kommunikation zwischen dem Business und Entwicklern kann es oft zu Missverständnisse kommen. Womöglich weil Informationen, Einschränkungen oder Prozesse ausgelassen bzw. für selbstverständlich erachtet werden. Durch die klare Definition von gemeinsam verwendeten Begriffen und ihren Bedeutungen wird implizit notwendiges Wissen über die Domain und ihre Eigenschaften geschaffen. Viele dieser Fachbegriffe können für notwendige Anwendungsfälle wiederverwendet werden und machen die Personen, welche letztendlich die Businessanforderungen umsetzten sollen, mit der Domain vertraut. Da ein Team mit geringem Domainwissen auch die Korrektheit der Software gefährdet, stellt die Ubiquitous Language ein wichtiger Meilenstein in Domain-Driven Design dar.

In Zusammenarbeit mit dem Lead-Developer und \Gls{Product Owner} des Teams wird im folgenden Abschnitt die Ubiquitous Language definiert, um ein solches Verständnis über den Checkout Bounded-Context zu gewährleisten. Hierbei wurde sich auf die, für dieses Projekt, relevanten Terme beschränkt und stellt lediglich eine mögliche Umsetzung einer Ubiquitous Language dar. Dank der Planungsphase sind zahlreiche Begriffe bereits definiert und helfen bei der Erstellung einer solchen Dokumentation. Eingeklammerte Wörter beschreiben Synonyme zu dem vorangestellten Ausdruck.

{\large \textbf{Ubiquitous Language des Domain-Modells:}}
\begin{itemize}[topsep=-3px]
	\item \textbf{Basket (Warenkorb): } {Repräsentiert den gesamten Warenkorb mit allen Artikel, Kundeninformationen, Preisen etc.}
	\item \textbf{Basket Status: } {Stellt den aktuellen Zustand des Baskets dar, welcher sich an den Prozessen orientiert. Kann die Werte 'open', 'frozen', 'finalized' und 'canceled' annehmen. Der Startzustand ist hierbei 'open'.}
	\item \textbf{Customer (Kunde): } {Ein Endkunde des Onlineshops oder im Markt. Kann eine zivile Person oder Firma sein. Ein nicht-eingeloggter Kunde im Onlineshop wird der zugehörige Warenkorb durch seine eindeutige Session-ID zugewiesen.} 
	\item \textbf{Product (Artikel, Ware): } {Ein Artikel aus dem Warenbestand, welcher zu Verkauf steht. Kann ebenfalls für eine Gruppierung von mehreren Artikeln stehen.}
	\item \textbf{Outlet: } {Repräsentiert einen Markt oder den länderbezogenen Onlineshop, welche durch eine einzigartige Outlet-Nummer referenziert werden.}
	\item \textbf{BasketItemId: } {Eine, innerhalb eines Baskets, eindeutige Referenz auf ein Artikel des Warenkorbs. Wird aus technischen Gründen benötigt, um einen Eintrag zu bearbeiten oder entfernen.}
	\item \textbf{Net Amount (Nettobetrag): } {Ein Nettobetrag mit Währung.}
	\item \textbf{VAT (Steuersatz): } {Der Steuersatz eines zugehörigen Nettobetrag.}
	\item \textbf{Gross Amount (Bruttobetrag): } {Der Bruttobetrag eines Preises errechnet aus dem Steuersatz und Nettobetrag. Die Währung gleicht die des Nettobetrags.}
	\item \textbf{Fulfillment: } {Zustellungsart der Waren seitens der Firma.}
	\begin{itemize}[noitemsep,nolistsep, topsep=-5px]
		\item \textit{Pickup: } {Warenabholung in einem ausgewählten Markt durch den Kunden. Nur möglich sofern Artikel im Markt auf Lager ist.}
		\item \textit{Delivery: } {Zustellung der Ware an den Kunden durch einen Vertragspartner.}
		\item \textit{Packstation: } {Lieferung der Ware an eine ausgewählte Packstation durch einen Vertragspartner.}
	\end{itemize}
	\item \textbf{Payment Process (Zahlungsprozess): } {Beinhaltet alle relevanten Informationen für das Bezahlen eines Warenkorbs, wie ausgewählte Zahlungsarten und Beträge.}
	\item \textbf{Payment: } {Zahlung des Kunden inklusive Betrag und Zahlungsmethode, wie Barzahlung oder Paypal.}
	\item \textbf{Order: } {Bestellung eines Warenkorbs nach Abschluss des Zahlvorgangs, welche durch nachfolgende Systeme angelegt und verwaltet wird.}
\end{itemize}

\vspace{2em}

{\large \textbf{Ubiquitous Language der Businessprozesse:}}
\begin{itemize}[topsep=-3px]
	\item \textbf{Touchpoint: } { Eine Komponente, welche mit der Checkout-Software interagiert, wie Kassensysteme im Markt, die Onlineshop-Seite oder Handy-App.}
	\item \textbf{Basket Validation: } {Durchführung einer Validierung des Baskets auf Inkonsistenzen oder fehlende jedoch notwendige Werte.}
	\item \textbf{Basket Finalization: } {Erfolgt automatisch nach erfolgreichem Zahlvorgang und setzt den Warenkorb in den Zustand 'finalized'. Danach folgt die Reservierung der Produkte im Basket und das Anlegen einer neuen Bestellung.}
	\item \textbf{Basket Cancellation: } {Stornieren des zugehörigen Baskets mithilfe des Zustandswechsel auf 'canceled'. Nach Cancellation dürfen keine weiteren Änderungen an den Basket durchgeführt werden. Der Warenkorb muss sich zuvor im Zustand 'open' befinden. }
	\item \textbf{Basket Creation: } {Explizite oder Implizite Erstellung eines neuen Baskets. Findet automatisch statt sofern noch kein Basket für den Customer existiert, sowie nach einer Basket Finalization.}
	\item \textbf{Basket Calculation: } {Das Berechnen der Summe von beinhalteten Preisen des Baskets, sowie die Kalkulation von Bruttobeträgen für alle Artikel. Beträge aus unterschiedlichen Mehrwertsteuern müssen weiterhin aus rechtlichen Gründen einzeln verwiesen werden können.}
	\item \textbf{High Volume Ordering: } {Die Bestellung von Artikeln in hoher Stückzahl. Aufgrund von Businessanforderungen soll es nur begrenzt möglich sein, dass ein Kunde in einem Basket oder wiederholt das gleiche Produkt mehrfach kauft.}
	\item \textbf{Payment Initialization: } {Start des Zahlungsvorgangs, nachdem der Warenkorb auf invalide Zustände überprüft wird. Nur möglich auf einen offenen Basket, welcher Produkte und Payments enthält. Resultiert in den Zustand 'frozen', wodurch keine weiteren Inhaltsänderungen an den Warenkorb durchgeführt werden dürfen.}
	\item \textbf{Payment Execution: } {Durchführung des Zahlungsvorgangs eines gefrorenen Basket. Anschließend findet die Basket Finalization statt.}
\end{itemize}
\vspace{2em}

Im Verlaufe der Definitionsphase der Ubiquitous Language wurden die Prozesse näher beleuchtet, Benamungen von Datenobjekten aufdeckt und Businessanforderungen vorgegeben. Ein gutes Datenmodell spiegelt hierbei ebenfalls die Sprache des Bounded-Contexts wider, daher wird auf Basis dieses Unterkapitels die Klassen designt. 

\section{Definition der Value Objects}

Aufgrund der Simplizität und klaren Zuteilung der Value Objects lassen sich diese als leichtes bestimmen. Anfangs sollte jede Datenstruktur des Domain-Modells als ein Value Object definiert und erst nach gründlicher Überlegung, falls die Notwendigkeit besteht, zu einer Entity umgeschrieben werden. Der Basket stellt hierbei den Ausgangspunkt der Modellierung dar und die Ubiquitous Language unterstützt bei der richtigen Klassen-Benamung. Es wird auf ein schlankes Design im Vergleich zur Produktivanwendung geachtet, ohne dabei mögliche Aggregate-Designs zu beeinflussen.

\domainModell{Basket-Klasse}{
	\item \textbf{BasketId: } {Eindeutige Identifikation des Baskets zur Referenzierung durch die Touchpoints.}
	\item \textbf{OutletId: } {Eine Referenz zugehörig zu dem Markt oder Onlineshop, durch welchen der Warenkorb angelegt wurde. Unerlässlich für die Bestimmung von unter anderem Lagerbeständen, Lieferzeiten, Fulfillment-Optionen und Versandkosten.}
	\item \textbf{BasketStatus: } {Repräsentiert den aktuellen Zustands des Warenkorbs. Mögliche Werte sind OPEN, FROZEN, FINALIZED und CANCELED.} 
	\item \textbf{Customer: } {Speichert Kundendaten (IdentifiedCustomer) oder Session-Informationen (SessionCustomer).} 
	\item \textbf{FulfillmentType: } {Lieferart, wie PICKUP oder DELIVERY.} 
	\item \textbf{BillingAddress: } {Adresse für die Rechnungserstellung.} 
	\item \textbf{ShippingAddress: } {Adresse für die Warenlieferung.} 
	\item \textbf{BasketItems: } {Liste aller enthaltenen Produkten im Warenkorb und ihren zugehörigen Informationen.}
	\item \textbf{BasketCalculationResult: } {Beinhaltet die berechneten Werte des Warenkorbs, wie Nettobetrag, Bruttobetrag und Mehrwertsteuer. Die Speicherung dieser Werte wäre technisch nicht notwendig, spart aber an Rechenzeit ein, da nicht bei jeder Abfrage des Basket dieser Wert neu berechnet werden muss.}
	\item \textbf{PaymentProcess: } {Bindet alle Informationen zur erfolgreichen Abwicklung des Zahlungsprozesses.}
	\item \textbf{Order: } {Speichert eine Referenz auf die Bestellung für einen Basket. Wird erst nach Zahlungsabschluss befüllt.}  
}

\vspace{1em}
Die im Basket enthaltenen Klassen sind ebenfalls mit der gleichen Vorgehensweise im Anhang unter \ref{label:Daten-Modell} definiert worden, sofern sie nicht durch einen einfachen Text oder Aufzählungen darstellbar sind, bzw. ihre Inhalte keine nähere Erklärung erfordern. \\\\

\comment{Im Anhang oder direkt darunter hinzufügen?}

Durch diese Datenstruktur ist es möglich, alle geforderten Anwendungsfälle korrekt abzuarbeiten. Um eine klare Gesamtübersicht zu bieten, wurde das Modell in mehrere Klassendiagramme unterteilt. In Figur \ref{fig:VO-Basket} ist das Ergebnis dieses Unterkapitels abgebildet. Die Klasse \ul{Customer} und \ul{PaymentProcess} wurden aus Platzgründen in separate Diagramme \ref{fig:VO-Customer} und \ref{fig:VO-Payment} verlagert. Anzumerken ist, dass bei fehlender Multiplizität eine Eins-zu-Eins Beziehung vorliegt. Speziell, ist der Kunde in diesem Kontext genau einem Warenkorb zugewiesen, da alleinig die Daten abgespeichert werden, nicht aber seine Kundennummer, wodurch keine Zuweisung zwischen Kunde und mehreren Warenkörben existiert.

\comment{Im Anhang oder direkt darunter hinzufügen?}

\begin{figure}[htbp]
	\centering
	\includesvg[inkscapelatex=false, width=0.95\textwidth]{svg/ValueObjectBasketDiagram.svg}
	\caption{Klassendiagramm eines Baskets}
	\label{fig:VO-Basket}
\end{figure}

\begin{figure}[htbp]
	\centering
	\includesvg[inkscapelatex=false, width=0.95\textwidth]{svg/ValueObjectCustomerDiagram.svg}
	\caption{Zugehöriges Klassendiagramm des Customer Value Objects}
	\label{fig:VO-Customer}
\end{figure}

\begin{figure}[htbp]
	\centering
	\includesvg[inkscapelatex=false, width=0.95\textwidth]{svg/ValueObjectPaymentDiagram.svg}
	\caption{Darstellung des Payment Process als Klassendiagramm}
	\label{fig:VO-Payment}
\end{figure}

\comment{Die Klassendiagramme sind noch sehr visuell 'unschön'...}


\section{Bestimmung der Entities anhand ihrer Identität und Lebenszyklen}

Auf Basis der vorgehenden Sektion ist das Datenmodell nun vollständig definiert. Jedoch besteht weiterhin die Frage, ob die jeweiligen Klassen eine eigene Identität besitzen und somit als Entity designt werden müssen. Es existiert in Domain-Driven Design kein objektives Verfahren zur Bestimmung der Entities, da je nach Bounded-Context Datengruppierungen unterschiedliche Eigenschaften besitzen. Als Hilfestellung für diese Entscheidung können folgende grundlegende Unterscheidungsmerkmale und Richtlinien in Tabelle \ref{fig:entityvsvalueobject} verwendet werden.

\begin{table}[h!]
	\begin{tabular}{ | >{\centering\arraybackslash}m{0.16\textwidth} | m{0.33\textwidth} | m{0.43\textwidth} | } 
		\hline
		& \vspace{0.8mm}\textbf{Value Object}\vspace{0.5mm} & \vspace{0.8mm}\textbf{Entity}\vspace{0.5mm} \\ 
		\hline
		{\centering Identität} & 
		\centertable{Summe der Werte der Objekte. Objekte mit gleichen Werten besitzen gleiche Identität.} & 
		\centertable{Bestimmt anhand eines Identifikators, zum Beispiel einer Datenbank-Id. Objekte gelten als ungleich, außer ihre Identifikatoren sind identisch.} \\ 
		\hline
		Lebenszyklus & 
		\centertable{Stellt nur eine Momentaufnahme des Applikationszustands dar.} &
		\centertable{Werden zu einem bestimmten Zeitpunkt erstellt, bearbeitet, gespeichert oder gelöscht. Besitzen somit einen impliziten Verlauf ihrer Wertänderungen.}  \\ 
		\hline
		Veränderbarkeit & 
		\centertable{Durch einen fehlenden Lebenszyklus gelten Value Objects als \gls{immutable}.} &
		\centertable{Aufgrund ihrer Eigenschaften sind Entities veränderbar.}  \\ 
		\hline
		Abhängigkeit & 
		\centertable{Können nur als Unterobjekt von Entities existieren.} &
		\centertable{Damit ein eigener Lebenszyklus ermöglicht wird, können sie unabhängig von anderen Objekten leben.}  \\ 
		\hline
		Zugriffsmethode & 
		\centertable{Auf Daten und Funktionen wird mithilfe einer Entität zugegriffen.} &
		\centertable{Können als Aggregate Root, oder durch diesen, direkten Zugriff erfahren.} \\ 
		\hline
	\end{tabular}
	\caption{Vergleich zwischen Value Object und Entity}
	\label{fig:entityvsvalueobject}
\end{table}


Anhand dieser Eigenschaften können die Value Objects untersucht und daraufhin alle Entities bestimmt werden:

\domainModellWithoutTitle{
	\item \textbf{Basket: } {Als zentrales Datenobjekt besitzt ein Basket zur eindeutigen Identifikation durch den Touchpoint eine Referenznummer. Diese Eigenschaft spricht stark für eine Entity. Zusätzlich bestimmen nicht die enthaltenen Attribute wie Products oder der zugehörige Kunde die Identität des Baskets, sondern alleinig diese Id. Aufgrund der geforderten Anwendungsfälle entsteht zugleich ein Lebenszyklus für die Instanzen eines Baskets und er durchgeht verschiedene Zustandsänderungen. Folglich ist ein Basket eine \emph{Entity}.}
	\item \textbf{IdentifiedCustomer: } {In Bounded-Contexts, welche mit den Kundendaten operieren, kann diese Klasse durchaus eine Entity darstellen. In der Checkout-Domain finden keine Operationen auf diesen Informationen statt und die vorangestellten Systeme senden bei Änderungen der Kundendaten diese zu. Folglich besitzen sie keinen eigenen Lebenszyklus und können weiterhin als \emph{Value Object} designt werden.}
	\item \textbf{SessionCustomer: } {Die Identifikation dieses Objekts geschieht über die SessionId. Dadurch ist ein SessionCustomer in der Gruppe der \emph{Entities} aufzuhängen. }
	\item \textbf{Basket-Item: } {Auf erstem Blick ist ein Basket-Item als Entity zu designen. Es besitzt eine eigene Id und wird durch das Aktualisieren der Preise und Produktdaten bearbeitet. Somit entsteht ebenfalls ein Lebenszyklus. Jedoch lassen sich auch Argumente finden, warum ein Item durchaus ein Value Object sein kann. Die Identifikation erfolgt zwar durch eine Id, allerdings kann dies durch folgenden Anwendungsfall hinterfragt werden. Wenn das gleiche Produkt mehrmals sich im Basket befindet, existieren auch mehrere zugehörige Basket-Items. Bei der Anpassung der Quantität beispielsweise von vier auf eins, werden alle Items gesucht, welche das gleiche Produkt besitzen, und davon drei gelöscht. Dies würde aber bedeuten, dass ein Basket-Item zusätzlich anhand seines Produktes identifiziert wird. Sollte die ProductId die Identität des Baskets ausmachen, dann wären alle Basket-Items mit dem gleichen Produkt auch identisch. Dies stimmt allerdings nur bedingt, da sie sich theoretisch durch unterschiedliche Preise und Serviceangebote (in der Produktivumgebung) unterscheiden können. Als Folgerung kann geschlossen werden, dass ein Basket-Item lediglich eine Momentaufnahme darstellt, wodurch das Design als Value Object berechtigt wäre. Letztendlich kann das Basket-Item in diesem Bounded-Context als Entity oder Value Object definiert werden. Für den Proof-of-Concept wurde das Basket-Item als Entity festgelegt. Die Begründung hierfür ist die schiere Anzahl von Datenanpassungen und Operationen auf einem Basket-Item, welche als \emph{Entity} natürlicher bewältigt werden können.}
	\item \textbf{Product und Price: } {Die vorgehende Analyse des Basket-Items kann auch auf das Product und den Price angewandt werden. Beide besitzen eine Id zur Identifikation und werden stetig aktualisiert. Allerdings sind Prices bzw. Products mit ungleichen Werten aber gleicher Id in diesem Kontext auch unterschiedliche Objekte. Theoretisch ist auch hier eine Entscheidung für beide Möglichkeiten vertretbar. Jedoch ist das Datenkonstrukt beider Klassen relativ klein und Anpassungen betreffen nahezu alle Attribute, wodurch ein unveränderliches Design natürlich ausfällt. Als Folge dessen sind beide Klassen als \emph{Value Object} umgesetzt worden. }
	\item \textbf{Calculation-Result: } {Als Datenstruktur, welche bei jeder Neuberechnung aktualisiert wird, könnte die Eigenschaft eines Lebenszyklus erfüllt sein. Dennoch stellt die Klasse einzig ein Zwischenspeicher der Ergebnisse dar und ohne den Kontext eines darüberlegenden, zugehörigen Objektes besitzen diese Daten keine Aussagekraft. Weiterhin sind die gleichen Ergebnisse unterschiedlicher Baskets im Sinne der Identität äquivalent. Dadurch überwiegen die Argumente für ein \emph{Value Object}.}
	\item \textbf{Payment-Process: } {Der Bezahlungsprozess besitzt zur korrekter Ausführung ein Feld zum Speichern des aktuellen Status. Somit ist ein Lebenszyklus zuweisbar. Die Identität eines Payment Processes ist gleich mit der BasketId, da eine Eins-zu-Eins Relation zwischen ihnen existiert. Die Lebensdauer des Objektes ist somit auch an die des Baskets gebunden. Weiterhin verwaltet ein Payment-Process alle darunterliegenden Payments. Zusammenfassend spricht jede Eigenschaft für ein Design als \emph{Entity}.}
	\item \textbf{Payment: } {Ein Payment hat eine eindeutige Id, welche eine hohe Relevanz für den Ablauf des Bezahlprozesses und alle folgenden rechtlichen Prozesse hat. Dadurch ist weder der konkrete Betrag noch die Bezahlmethode bei der Identifikation wichtig. Ähnlich zum Payment-Process ist auch hier ein Lebenszyklus im Form eines Statusfeldes vertreten und eine Verwirklichung als \emph{Entity} ist zu empfehlen.}
}



