
%% PROOF OF CONCEPT %% 

\chapter{Festlegung des Datenmodells durch Domain-Driven Design}

Durch die Schaffung eines grundlegenden Verständnisses für Designprinzipien, Hexagonaler Architektur und Domain-Driven Design kann auf zusätzlicher Basis der vorherigen Analysen ein Proof-of-Concept der Checkout-Software entwickelt werden. Hierzu wird weiterhin das typische Vorgehen eines Domain-Driven Designs verfolgt und zunächst der Domainumfang und die Ubiquitous Language definiert, gefolgt vom Erstellen des zentralen Domain-Modells.

\section{Abgrenzung der Domain und Bounded Contexts mithilfe der Planungsphase}

Aufgrund der ausführlichen Vorbereitung wurde die Domain bereits passiv festgelegt und analysiert. Beispielsweise beschreibt das Context-Diagramm \ref{fig:ContextDiagramm} hierbei unsere Domaingrenzen. Eine Domain und die dazugehörigen Subdomains spannen den Problemraum über alle definierten Anwendungsfälle und Businessanforderungen auf \cite[S. 56]{Vernon.2015}. Die Größe der Domain ist entscheidend für die Bestimmung der Subdomains und des Bounded-Contexts. Wird der Checkout als eine Domain angesehen, ergibt sich insgesamt nur ein Bounded-Context, da grundlegend pro Bounded-Context nur maximal ein Team zuständig sein sollte \cite{Brandolini.2021}. Der Checkout müsste somit weitere Unterteilungen erfahren oder alternativ die Domain vergrößert werden. Folglich wird als nächstmögliche Eingrenzung der Checkout und alle abhängigen Systeme angesehen. Zu beachten ist hierbei, sich nicht auf die konkreten Systeme zu fixieren, da sie eher der Lösungsebene zuweisbar sind, sondern logisch naheliegende Aufgaben in einer Gruppe zusammenzufassen. In den Zuständigkeitsbereich der Domain fallen unter anderem Anforderungen an der Abwicklung des Zahlungs- und Bestellprozesses, sowie Bereitstellung von Preis- bzw. Artikelinformationen. Hierfür muss ebenfalls eine Verwaltungsmöglichkeit für diese Daten bereitgestellt werden. Die Abgrenzungen der Bounded-Contexts ist durch die jetzigen Überlegungen und die bereits bestehende Architektur vorgegeben, wodurch das Context-Diagramm \ref{fig:ContextDiagramm} zugleich als Context-Map fungieren kann.

\section{Festlegen einer Ubiquitous Language}

In der Kommunikation zwischen dem Business und Entwicklern kann es oft zu Missverständnissen kommen. Womöglich weil Informationen, Einschränkungen oder Prozesse ausgelassen bzw. für selbstverständlich erachtet werden. Durch die klare Definition von gemeinsam verwendeten Begriffen und ihren Bedeutungen wird implizit notwendiges Wissen über die Domain und ihre Eigenschaften geschaffen. Viele dieser Fachbegriffe können für Anwendungsfälle verwendet werden und machen die Personen, welche letztendlich die Businessanforderungen umsetzten sollen, mit der Domain vertraut. Da ein Team mit geringem Domainwissen auch die Korrektheit der Software gefährdet, ist die Ubiquitous Language ein wichtiger Meilenstein im Domain-Driven Design. \cite[S. 335ff.]{Evans.2011}

In Zusammenarbeit mit dem Lead-Developer und \emph{\Gls{Product Owner}} des Teams wird im folgenden Abschnitt die Ubiquitous Language definiert, um ein tieferes Verständnis über den Bounded-Context zu gewährleisten. Hierbei wurde sich auf die, für dieses Projekt, relevanten Terme beschränkt und ist lediglich eine mögliche Umsetzung einer Ubiquitous Language. Dank der Planungsphase sind zahlreiche Begriffe bereits definiert und helfen bei der Erstellung einer solchen Dokumentation. Eingeklammerte Wörter beschreiben Synonyme zu dem vorangestellten Ausdruck.

{\large \textbf{Ubiquitous Language des Domain-Modells:}}
\begin{itemize}[topsep=-3px]
	\item \textbf{Basket: } {Repräsentiert die Funktionalität eines Warenkorbs mit allen Artikeln, Kundeninformationen, Preisen etc.}
	\item \textbf{Basket Status: } {Stellt den aktuellen Zustand des Baskets dar, welcher sich an den Prozessen orientiert. Kann die Werte 'Open', 'Frozen', 'Finalized' und 'Canceled' annehmen. Der Startzustand ist hierbei 'Open'.}
	\item \textbf{Customer (Kunde): } {Ein Endkunde des Onlineshops oder im Markt. Kann eine zivile Person oder Firma sein. Einem nicht-eingeloggten Kunden wird der zugehörige Basket im Onlineshop durch seine eindeutige Session-ID zugewiesen.} 
	\item \textbf{Product (Artikel, Ware): } {Ein Artikel aus dem Warenbestand, welcher zu Verkauf steht. Kann ebenfalls für eine Gruppierung von mehreren Artikeln stehen.}
	\item \textbf{Outlet: } {Repräsentiert einen Markt oder den länderbezogenen Onlineshop, welcher durch eine einzigartige Outlet-Nummer referenziert wird.}
	\item \textbf{BasketItemID: } {Eine, innerhalb eines Baskets, eindeutige Referenz auf einen enthaltenen Artikel. Wird aus technischen Gründen benötigt, um Einträge zu bearbeiten oder entfernen.}
	\item \textbf{Net Amount (Nettobetrag): } {Ein Nettobetrag mit Währung.}
	\item \textbf{VAT (Steuersatz): } {Der Steuersatz eines zugehörigen Nettobetrags.}
	\item \textbf{Gross Amount (Bruttobetrag): } {Der Bruttobetrag eines Preises errechnet aus dem Steuersatz und Nettobetrag. Die Währung gleicht der des Nettobetrags.}
	\item \textbf{Fulfillment: } {Zustellungsart der Waren seitens der Firma.}
	\begin{itemize}[noitemsep,nolistsep, topsep=-5px]
		\item \textit{Pickup: } {Warenabholung in einem ausgewählten Markt durch den Kunden. Nur möglich sofern Artikel im Markt auf Lager ist.}
		\item \textit{Delivery: } {Zustellung der Ware an den Kunden durch einen Vertragspartner.}
		\item \textit{Packstation: } {Lieferung der Ware an eine ausgewählte Packstation durch einen Vertragspartner.}
	\end{itemize}
	\item \textbf{Payment Process (Zahlungsvorgang): } {Beinhaltet alle relevanten Informationen für das Verwalten eines Zahlungsvorgangs, wie Beträge und getätigte Zahlungen.}
	\item \textbf{Payment: } {Eine einzelne Zahlung des Kunden inklusive Betrag und Zahlungsmethode, wie Barzahlung oder PayPal.}
	\item \textbf{Order: } {Bestellung eines Baskets nach Abschluss des Zahlungsvorgangs. Wird durch nachfolgende Systeme angelegt und verwaltet.}
\end{itemize}

\pagebreak

{\large \textbf{Ubiquitous Language der Businessprozesse:}}
\begin{itemize}[topsep=-3px]
	\item \textbf{Touchpoint: } { Eine Komponente, welche mit der Checkout-Software interagiert, wie Kassensysteme im Markt, die Onlineshop-Seite oder Handy-App.}
	\item \textbf{Basket Cancellation: } {Stornieren des zugehörigen Baskets mithilfe eines Zustandswechsels auf 'Canceled'. Nach der Cancellation dürfen keine weiteren Änderungen an dem Basket durchgeführt werden. Der Zustand muss zuvor 'Open' sein. }
	\item \textbf{Basket Creation: } {Explizite oder Implizite Erstellung eines neuen Baskets. Geschieht automatisch sofern noch kein Basket für den Customer existiert oder nach einer Basket Finalization.}
	\item \textbf{Basket Calculation: } {Die Kalkulation von Bruttobeträgen aller Artikel sowie der Summe von beinhalteten Preisen des Baskets. Beträge aus unterschiedlichen Mehrwertsteuersätzen müssen weiterhin aus rechtlichen Gründen einzeln verwiesen werden können.}
	\item \textbf{High Volume Ordering: } {Die Bestellung von Artikeln in hoher Stückzahl. Aufgrund von Businessanforderungen soll es nur begrenzt möglich sein, dass ein Kunde innerhalb eines Baskets oder in mehreren Bestellungen das gleiche Produkt mehrfach kauft.}
	\item \textbf{Basket Validation: } {Durchführung einer Validierung des Baskets auf Inkonsistenzen oder fehlenden, jedoch notwendigen, Werten.}
	\item \textbf{Payment Initialization: } {Start des Zahlungsvorgangs, nachdem das Datenmodell auf invalide Zustände überprüft worden ist. Nur möglich bei einem offenen Basket, welcher Produkte und Payments enthält. Resultiert in den Zustand 'Frozen', wodurch keine weiteren Inhaltsänderungen an dem Basket vorgenommen werden können.}
	\item \textbf{Payment Execution: } {Durchführung des Zahlungsvorgangs eines gefrorenen Baskets. Anschließend findet die Basket Finalization statt.}
	\item \textbf{Basket Finalization: } {Erfolgt automatisch nach erfolgreichem Zahlungsvorgang und setzt den Basket in den Zustand 'Finalized'. Danach folgt die Reservierung der Produkte und das Anlegen einer neuen Bestellung.}
\end{itemize}
\vspace{2em}

Im Verlaufe der Definitionsphase der Ubiquitous Language wurden die Prozesse näher beleuchtet, Benamungen von Datenobjekten aufgedeckt und Businessanforderungen vorgegeben. Ein gutes Modell spiegelt die Sprache des Bounded-Contexts wider, weshalb auf Basis dieses Unterkapitels die Klassen designt werden. 

\pagebreak

\section{Definition der Value Objects}

Aufgrund der positiven Eigenschaften von Value Objects sollte anfangs jede Datenstruktur des Domain-Modells als ein solches implementiert und erst nach gründlicher Überlegung, falls die Notwendigkeit besteht, zu einer Entity umgeschrieben werden \cite[S. 219f.]{Vernon.2015}. Der Basket ist hierbei der Ausgangspunkt des Modells. Es wird auf ein schlankes Design im Vergleich zur Produktivanwendung geachtet, ohne dabei mögliche Aggregationsschnitte zu beeinflussen. Die Ubiquitous Language unterstützt bei der richtigen Klassen-Benamung. \\

\groupedDomainModell{Basket}{
	\item \textbf{BasketId: } {Eindeutige Identifikation des Baskets zur Referenzierung durch die Touchpoints.}
	\item \textbf{OutletId: } {Eine Referenz zugehörig zu einem Markt oder Onlineshop, durch welchen der Basket angelegt wurde. Unerlässlich für die Bestimmung von unter anderem Lagerbeständen, Lieferzeiten, Fulfillment-Optionen und Versandkosten.}
	\item \textbf{BasketStatus: } {Repräsentiert den aktuellen Zustand des Baskets. Mögliche Werte sind 'OPEN', 'FROZEN', 'FINALIZED' und 'CANCELED'.} 
	\item \textbf{Customer: } {Speichert Kundendaten (IdentifiedCustomer) oder Session-Informationen (SessionCustomer).} 
	\item \textbf{FulfillmentType: } {Lieferart, wie 'PICKUP' oder 'DELIVERY'.} 
	\item \textbf{BillingAddress: } {Adresse für die Rechnungserstellung.} 
	\item \textbf{ShippingAddress: } {Adresse für die Warenlieferung.} 
	\item \textbf{BasketItems: } {Liste aller enthaltenen Produkte und ihre zugehörigen Informationen.}
	\item \textbf{BasketCalculationResult: } {Beinhaltet die berechneten Werte des Basket, wie Nettobetrag, Bruttobetrag und Mehrwertsteuer. Die Speicherung dieser Werte wäre technisch nicht notwendig, spart aber Rechenzeit, da nicht bei jeder Abfrage des Basket dieser Wert neu berechnet werden muss.}
	\item \textbf{PaymentProcess: } {Enthält alle Informationen zur erfolgreichen Abwicklung des Zahlungsprozesses.}
	\item \textbf{Order: } {Speichert eine Referenz auf die Bestellung eines Baskets. Wird erst nach Zahlungsabschluss befüllt.}  
}

\vspace{1em}

Durch diese Datenstruktur ist es möglich, alle geforderten Anwendungsfälle korrekt abzuarbeiten. Die untergegliederten Klassen sind ebenfalls mit der gleichen Vorgehensweise in Anhang \ref{label:Daten-Modell} definiert worden, sofern sie nicht durch einen einfachen Text oder Aufzählungen realisierbar sind. Um eine klare Gesamtübersicht zu bieten, wurde ein Klassendiagramm der Datenstruktur dem Anhang \ref{fig:VO-Basket} hinzugefügt. Die Klassen \ul{Customer} und \ul{PaymentProcess} wurden aus Platzgründen in separate Klassendiagramme in Anhang \ref{fig:VO-Customer} und \ref{fig:VO-Payment} verlagert. Anzumerken ist, dass bei fehlender Multiplizität eine Eins-zu-Eins Beziehung vorliegt. Speziell, ist der Kunde in diesem Kontext genau einem Basket zugewiesen, da alleinig die Daten abgespeichert werden, nicht aber seine Kundennummer, wodurch keine Zuweisung zwischen einem Kunden und mehreren Warenkörben existiert.

\section{Bestimmung der Entities anhand ihrer Identität und Lebenszyklen}

Auf Basis der vorangehenden Sektion ist das Datenmodell nun vollständig definiert. Jedoch besteht weiterhin die Frage, ob die jeweiligen Klassen eine eigene Identität besitzen und somit als Entity designt werden müssen. Es existiert in Domain-Driven Design kein objektives Verfahren zur Bestimmung der Entities, da Datengruppierungen je nach Bounded-Context unterschiedliche Eigenschaften besitzen. Als Hilfestellung für diese Entscheidung können grundlegende Richtlinien aus Tabelle \ref{fig:entityvsvalueobject} verwendet werden.

\begin{table}[h!]
	\begin{tabular}{ | >{\centering\arraybackslash}m{0.16\textwidth} | m{0.33\textwidth} | m{0.43\textwidth} | } 
		\hline
		& \vspace{0.8mm}\textbf{Value Object}\vspace{0.5mm} & \vspace{0.8mm}\textbf{Entity}\vspace{0.5mm} \\ 
		\hline
		{\centering Identität} & 
		\centertable{Summe aller Attribute des Objekts. Objekte mit gleichen Werten besitzen gleiche Identität. \cite[S. 99]{Evans.2011}} & 
		\centertable{Bestimmt anhand eines Identifikators, zum Beispiel einer Datenbank-ID. Objekte gelten als ungleich, außer ihre Identifikatoren sind identisch. \cite[S. 92]{Evans.2011}} \\ 
		\hline
		Lebenszyklus & 
		\centertable{Stellt nur eine Momentaufnahme des Applikationszustands dar, da sie bei Änderungen ersetzt werden. \cite[S. 226]{Vernon.2015}} &
		\centertable{Werden zu einem bestimmten Zeitpunkt erstellt, bearbeitet, gespeichert oder gelöscht. Besitzen somit einen impliziten Verlauf ihrer Wertänderungen. \cite[S. 91]{Evans.2011}}  \\ 
		\hline
		Veränderbarkeit & 
		\centertable{Durch einen fehlenden Lebenszyklus gelten Value Objects als \gls{immutable}. \cite[S. 99]{Evans.2011}} &
		\centertable{Aufgrund ihrer Eigenschaften sind Entities veränderbar. \cite[S. 91]{Evans.2011}}  \\ 
		\hline
		Abhängigkeit & 
		\centertable{Nur als Unterobjekt von Entities persistierbar, da sie kein Aggregate Root sein können.} &
		\centertable{Damit ein eigener Lebenszyklus ermöglicht wird, können sie unabhängig von anderen Objekten existieren.}  \\ 
		\hline
		Zugriffsmethode & 
		\centertable{Auf Daten und Funktionen wird mithilfe einer Entität zugegriffen.} &
		\centertable{Können als Aggregate Root, oder durch dieses, direkten Zugriff erfahren. \cite[S. 129]{Evans.2011}} \\ 
		\hline
	\end{tabular}
	\caption{Vergleich zwischen Value Object und Entity}
	\label{fig:entityvsvalueobject}
\end{table}


Anhand dieser Eigenschaften können die Value Objects untersucht und daraufhin alle Entities bestimmt werden:

\textbf{Basket: } {Als zentrales Datenobjekt besitzt ein Basket zur eindeutigen Identifikation durch den Touchpoint eine Referenznummer. Diese Eigenschaft spricht stark für eine Entity. Zusätzlich bestimmen nicht die enthaltenen Attribute wie Products oder der zugehörige Kunde die Identität des Baskets, sondern alleinig dessen ID. Aufgrund der geforderten Anwendungsfälle entsteht zugleich ein Lebenszyklus für die Instanzen eines Baskets und er durchgeht verschiedene Zustandsänderungen. Folglich ist ein Basket eine \emph{Entity}.}

\textbf{IdentifiedCustomer: } {Werden innerhalb eines Bounded-Contexts die Kundendaten verarbeitet, stellen diese meinst eine Entity dar. In der Checkout-Domain finden keine Operationen auf den Informationen statt. Die vorangestellten Systeme senden bei Änderungen die aktualisierten Kundendaten an die Checkout-Software. Folglich besitzen sie keinen eigenen Lebenszyklus und können als \emph{Value Object} designt werden.}

\textbf{SessionCustomer: } {Die Identifikation dieses Objekts geschieht über die Session-ID. Dadurch ist ein SessionCustomer in der Gruppe der \emph{Entities} aufzuhängen. }

\pagebreak

\textbf{Basket-Item: } {Auf den ersten Blick ist ein Basket-Item als Entity zu designen. Es besitzt eine eigene ID und wird durch das Aktualisieren der Preise und Produktdaten bearbeitet. Sie haben somit einen Lebenszyklus. Jedoch lassen sich auch Argumente finden, warum ein Item durchaus ein Value Object sein kann. Die Identifikation erfolgt zwar durch eine ID, allerdings kann dies durch folgenden Anwendungsfall hinterfragt werden. Wenn das gleiche Produkt mehrmals sich im Basket befindet, existieren im Datenmodell auch mehrere zugehörige Basket-Items. Bei der Reduzierung der Stückzahl eines Artikels beispielsweise von vier auf eins, werden alle Items gesucht, welche das gleiche Produkt repräsentieren, und davon drei gelöscht. Dies würde bedeuten, dass ein Basket-Item zusätzlich anhand seines Produktes identifiziert wird. Sollte die ProductID die Identität des Baskets ausmachen, dann wären alle Basket-Items mit dem gleichen Produkt auch identisch. Dies stimmt allerdings nur bedingt, da sie sich theoretisch durch unterschiedliche Preise und Serviceangebote (in der Produktivumgebung) differenzieren können. Als Folgerung kann geschlossen werden, dass ein Basket-Item lediglich eine Momentaufnahme darstellt, wodurch das Design als Value Object berechtigt wäre. Letztendlich kann das Basket-Item in diesem Bounded-Context als Entity oder Value Object definiert werden. Für den Proof-of-Concept wurde das Basket-Item als Entity festgelegt. Die Begründung hierfür ist die schiere Anzahl von Datenanpassungen und Operationen auf einem Basket-Item, welche als \emph{Entity} anhand ihrer Veränderbarkeit natürlicher bewältigt werden können.}

\textbf{Product und Price: } {Die vorgehende Analyse des Basket-Items kann auch auf das Product und den Price angewendet werden. Beide besitzen eine ID und werden stetig aktualisiert. Dennoch sind Prices bzw. Products mit ungleichen Werten aber gleicher ID in dem Checkout-Kontext unterschiedliche Objekte. Beide Klassen sind als \emph{Value Object} umgesetzt worden, da der Zusammenschluss aller ihrer Attribute als Identifikationsmerkmal verwendet wird. }

\textbf{Calculation-Result: } {Als Datenstruktur, welche bei jeder Neuberechnung aktualisiert wird, könnte die Eigenschaft eines Lebenszyklus erfüllt sein. Allerdings ist die Klasse einzig ein Zwischenspeicher der Ergebnisse zur Performance-Verbesserung. Ohne den Kontext eines darüberlegenden, zugehörigen Objektes besitzen diese Daten keine Aussagekraft. Die gleichen Berechnungsergebnisse unterschiedlicher Baskets sind im Sinne der Identität äquivalent. Dadurch überwiegen die Argumente eines \emph{Value Objects}.}

\textbf{Payment-Process: } {Der Payment-Process besitzt zur Ablaufsteuerung einen eigenen Status, weshalb ein Lebenszyklus entsteht. Die Identität eines Payment-Processes ist gleich mit der BasketID, da eine Eins-zu-Eins Relation zwischen ihnen existiert. Die Lebensdauer des Objektes ist somit auch an die des Baskets gebunden. Weiterhin verwaltet ein Payment-Process alle darunterliegenden Payments. Zusammenfassend sprechen die Eigenschaften für ein Design als \emph{Entity}.}

\textbf{Payment: } {Ein Payment hat eine eindeutige ID, welche für den Ablauf des Bezahlprozesses und alle folgenden rechtlichen Prozesse eine hohe Relevanz hat. Dadurch ist weder der konkrete Betrag, noch die Bezahlmethode bei der Identifikation wichtig. Ähnlich zum Payment-Process ist auch hier ein Lebenszyklus in Form eines Statusfeldes vorhanden. Eine Umsetzung als \emph{Entity} ist zu empfehlen.}



