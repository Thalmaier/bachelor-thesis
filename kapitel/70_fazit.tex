
%% FAZIT %% 

\chapter{Fazit und Empfehlungen}

Zu Beginn der Projektdurchführung wurden verschiedene Architekturstile untersucht und bewertet. Der Aufbau einer Hexagonalen Architektur unterstützt bei der Entkopplung des Applikationskerns und ermöglicht das instinktive Einhalten der SOLID-Prinzipien. Im Proof-of-Concept hat eine Einteilung in Adapter, Ports und Businesslogik den Entwicklungsprozess erleichtert. Die Hexagonale Architektur bildet ein stabiles und erweiterbares Fundament für die Checkout-Applikation. Zusätzlich fördert diese Softwarestruktur den Einsatz eines Domain-Driven Design, was einen effektiven Aggregationsschnitt ermöglicht, wodurch die Skalierbarkeit und Performance der Anwendung erhöht wird. 

Damit ein Umbau der aktuellen Produktivsoftware zu empfehlen ist, sollten die analysierten Domain-Modelle diese Qualitätsmerkmale positiv beeinflussen. Die Performance-Tests haben ergeben, dass der Einsatz eines kleineren Aggregationsschnitts keine Optimierung der Bearbeitungszeit zur Folge hat. Dies lässt sich auf die vielzähligen Datenbankoperationen bei einem aufgeteilten Aggregationsschnitt zurückführen, welche aufgrund der starken Kopplung einzelner Entitäten untereinander entstehen. In vielen Softwareprojekten existieren wenige Invarianten, die sich über das ganze Domain-Modell spannen \cite[S. 355ff.]{Vernon.2015}. Oftmals ist deshalb eine Trennung der Klassen voneinander problemlos möglich, sodass ein effektiveres Design erreicht werden kann. Der Basket ist allerdings ein enger Verbund aus Businessrichtlinien. Die transaktionale Konsistenz muss wegen fiskalischen Anforderungen stets eingehalten werden. Ein allumfassender Aggregationsschnitt ist aus Businesssicht somit ebenfalls sinnvoll. Zudem ist die parallele Bearbeitung eines Baskets zum jetzigen Zeitpunkt nicht notwendig, weshalb aus diesem Aspekt keine negativen Einflüsse durch den umfangreichen Aggregationsschnitt entstehen. Sofern die zeitgleiche Modifikation von Basket-Items zukünftig einen gängigen Anwendungsfall darstellt, müssen die Artikel als eigenständige Aggregates designt werden, wodurch ein verringerter Datendurchsatz und erhöhte Softwarekomplexität zu erwarten ist. Das Abspalten der Preiskalkulation ist ebenfalls denkbar, um Berechnungszeiten einzusparen. Die Komplexität des Sourcecodes steigt in diesem Fall leicht an. Sollten die Touchpoints bei der Mehrheit der API-Anfragen jedoch auch zugleich die neu kalkulierten Preise erwarten, verfallen die gewonnenen Performance-Verbesserungen. Weitere Designvariationen sind, anhand der in den jeweiligen Unterkapiteln besprochenen Auswirkungen, zur Verbesserung der Qualitätsmerkmale ungeeignet.

\textbf{Schlussendlich fallen die Argumente für eine Umgestaltung des Aggregationsschnittes in Zusammenhang mit den aktuellen Businessanforderungen zu schwach aus, sodass ein Re-Design der Applikation nicht empfehlenswert ist.}

Dennoch ist in den meisten Fällen ein kleinerer Aggregationsschnitt zu bevorzugen, da viele Applikationen kaum Invarianten besitzen. Allgemein kann sich in Softwareprojekten ein idealer Aggregationsschnitt mithilfe einer detaillierten Analyse der Anwendungsfälle und Integritätsgrenzen herauskristallisieren. Die ermittelten Invarianten zwischen Datenstrukturen bestimmen maßgeblich umsetzbare Designansätze. Ferner können verwendete Technologien durchaus Einfluss auf die Architektur der Software haben, allerdings sollte das mit dem Bewusstsein geschehen, dass sich diese zeitnah ändern können und deshalb bei deren Einbindung in den Entscheidungsprozess ein Risiko entsteht. Anforderungen an die Applikation und entstandene \emph{\gls{technische Schulden}} besitzen oftmals eine höhere Priorität im Vergleich zu den theoretischen Prinzipien des Softwaredesigns, da letztendlich eine funktionierende Software im Vordergrund steht. Eine zukunftssichere Applikation gelingt somit unter Einhaltung der gängigen Richtlinien eines Domain-Driven Designs in Kombination mit etablierten Designprinzipien und intuitiven Lösungsansätzen von erfahrenen Entwickler:innen.  