
%% FAZIT %% 

\chapter{Fazit und Empfehlungen}

Der Aufbau einer Hexagonalen Architektur unterstützt bei der Entkopplung des Applikationskerns und ermöglicht das instinktiv Einhalten der SOLID-Prinzipien. In dem Proof-of-Concept hat eine Einteilung in Adapter, Ports und Businesslogik den Entwicklungsprozess erleichtert. Zusätzlich lässt sich diese Softwarestruktur mit einem Domain-Driven Ansatz kombinieren. Die Hexagonale Architektur bildet ein stabiles und erweiterbares Fundament für die Checkout-Applikation.

Ein effektiver Aggregationsschnitt fördert die Skalierbarkeit und Performance der Anwendung. Damit ein Umbau der aktuellen Produktivsoftware zu empfehlen ist, sollten dementsprechend diese Qualitätsmerkmale positiv betroffen sein. 

Mithilfe der Performance-Analyse kann hierbei eine schnellere Bearbeitungszeit nicht verzeichnet werden. Dies lässt sich auf die vielzähligen Datenbankoperationen bei einem aufgeteilten Aggregationsschnitt zurückführen, welche aufgrund der starken Kopplung einzelner Entitäten untereinander entstehen. In vielen Softwareprojekten existieren kaum Invarianten, die sich über das ganze Domain-Modell spannen. Oftmals ist deshalb eine Trennung der Klassen voneinander problemlos möglich und ein verbessertes Aggregationsdesign kann dadurch erreicht werden. Der Warenkorb ist allerdings ein enger Verbund aus Businessrichtlinien und seine transaktionale Konsistenz muss wegen fiskalischen Anforderungen stets vorliegen. Ein allumfassender Aggregationsschnitt ist aus Businesssicht somit ebenfalls sinnvoll.

Zudem ist die mögliche parallele Bearbeitung eines Warenkorbs zum jetzigen Zeitpunkt nicht notwendig. Weshalb aus diesem Aspekt keine negativen Einflüsse durch den großen Aggregationsschnitt entstehen. Sofern zukünftig zeitgleiche Modifikationen an einem einzelnen Basket durch verschiedene Nutzer einen gängigen Anwendungsfall darstellen, müssen die Artikel als eigenständige Aggregates designt werden. Eine verringerte Performance und erhöhte Softwarekomplexität gehen im Gegenzug mit einem solchen Domain-Modell einher.

Das Abspalten der Preiskalkulation vom Warenkorb ist denkbar, um Berechnungszeiten einzusparen. Die Komplexität des Sourcecodes steigt in diesem Fall leicht an. Sollten die Touchpoints bei der Mehrheit der API-Anfragen jedoch auch zugleich die neu kalkulierten Werte erwarten, verfallen die Performance-Verbesserungen. Weitere Designvariationen sind, anhand der, in den jeweiligen Unterkapiteln besprochenen Auswirkungen zur Verbesserung der Qualitätsmerkmalen ungeeignet.

\textbf{Schlussendlich fallen die Argumente für einen Umgestaltung der Aggregationsaufteilung in Zusammenhang mit den aktuellen Businessanforderungen zu schwach aus, sodass ein Neudesign der Applikation nicht empfehlenswert ist.}

Allgemein kann sich in Softwareprojekten ein idealer Aggregationsschnitt mithilfe einer detaillierten Analyse der Anwendungsfälle und Integritätsgrenzen herauskristallisieren. Die ermittelten Invarianten zwischen Objekte bestimmen maßgeblich umsetzbare Designansätze. Ferner können verwendete Technologien durchaus einen Einfluss auf die Architektur der Software haben, allerdings sollte dies mit dem Bewusstsein geschehen, dass sich diese zeitnahe ändern können und weiterhin bei deren Einbindung in den Entscheidungsprozess ein Risiko entsteht. Anforderungen an die Applikation und in der Entwicklungsphase entstehende Kompromisse besitzen oftmals eine größere Priorität im Vergleich zu den theoretischen Prinzipien des Softwaredesigns. Diese bieten zwar Richtlinien für eine langlebige Anwendung, allerdings sind sie nicht immer die optimale Lösung für ein konkretes Problem. Der zugrundeliegende Antrieb für ihre Einhaltung sollte hinterfragt und bewusst gemacht werden. Nichtsdestotrotz ist in den meisten Fällen ein kleinerer Aggregationsschnitt zu bevorzugen, da viele Applikationen kaum starke Invarianten besitzen. Eine zukunftssicheres Software gelingt somit unter Einhaltung der gängigen Richtlinien eines Domain-Driven Designs in Kombination mit etablierten Designprinzipien und intuitiven Lösungsansätzen von erfahrenen Entwickler:innen.  

\comment{Zu wenig. Mehr ausformulieren. Mehr Zukunftsausblicke etc. Abruptes Ende...}
\comment{Service Mesh?}