
%% PLANUNG %% 

\chapter{Planungs- und Analysephase}

\comment{Bilder in Anhang oder direkt darunter?}

Der erfolgreiche Abschluss eines Projektes mit Domain-Driven Design erfordert die sorgfältige Analyse der Domain und des Bounded-Contexts. Basierend auf diesen Erkenntnissen kann das Domain-Modell und die Ubiquitous Language vollständig definiert werden. Besonders ist das Aggregate-Design stark von den Anwendungsfällen abhängig. Aus diesen Gründen wird im folgenden Kapitel eine umfassende Untersuchung des Bounded-Contexts stattfinden.

\section{Ausschlaggebende Anwendungsfallbeschreibungen}

Um den Kunden im Onlineshop oder den Mitarbeitern in den Märkten eine einwandfreie Benutzererfahrung zu gewährleisten, soll die Checkout-Software alle Prozesse vom Erstellen eines Warenkorbs bis hin zum Kaufabschluss verwalten können. Dadurch entstehen eine Vielzahl von relevanten Anwendungsfällen, welche alle korrekt und möglichst performant abgearbeitet werden müssen. Zur Dokumentation dieser Vorgänge empfiehlt es sich in der Entwicklungsphase die Prozesse in einem Diagramm abzubilden. Zusätzlich zu den Dokumentationszwecken kommt noch hinzu, dass eventuelle Unklarheiten aufgedeckt, Bedingungen an den Daten oder Programmfluss geklärt und sich eine natürliche Benutzung der Ubiquitous Language etabliert. Auf Basis dieser Anwendungsfälle ist es später möglich, Artefakte des Domain-Driven Designs leichter zu definieren. Vor allem die entscheidenden Invarianten bilden sich heraus und das Datenmodell kann klarer in Aggregates unterteilt werden. Die wichtigsten Anwendungsfälle für den Proof-of-Concept sind in diesem Kapitel vereinfacht beschrieben. Zu beachten bei der Reduzierung der Prozesse ist, dass Bedingungen zwischen Datenstrukturen weiterhin unverändert bleiben, damit die möglichen Aggregate-Designs im Zentrum dieser Arbeit nicht von den realisierbaren Varianten der Produktivanwendung abweichen. Dieses Kapitel dient somit als Grundlage für das Design der Software und wird in späteren Kapiteln referenziert. Die folgenden Prozesse wurden in Zusammenarbeit mit den Teams des Onlineshops, dem Checkout-Team und zuständigen \Gls{Stakeholder}n erarbeitet. Als Darstellungsmethode wurde sich auf Aktivitätsdiagramme geeinigt, damit die Interaktion zwischen den Systemen ebenfalls abgebildet werden kann. Diese sind im Anhang dieser Arbeit zu finden.

\subsection{Erstellung eines neuen, leeren Baskets}

Ein Basket, also ein Warenkorb, ist das grundlegendste Konstrukt des Checkouts. Die Anfrage auf Erzeugung eines Warenkorbs kann aus verschiedenen Gründen geschehen. Sollte ein nicht eingeloggter Kunde zum ersten Mal den Onlineshop aufrufen, wird ein neuer Basket mit der Session-ID als Kundeninformationen angelegt. Ein Warenkorb kann auch entstehen, wenn ein Mitarbeiter beispielsweise eine physikalische Kasse im Markt bedient und einen Kauf abschließt. Die verschiedenen Zugriffsmethoden, wie Onlineshop oder Handy-App, sind unter den Begriff 'Touchpoint' zusammengefasst.

Die Warenkorberstellung besteht hauptsächlich aus dem Empfangen der Kundendaten, die Identifikation des zugehörigen Marktes, hier als Outlet-ID bezeichnet, und dem permanenten Speicherns des neuen Warenkorbs. Dem Touchpoint wird das komplette Basket-Objekt zurückgegeben inklusive einer Basket-ID zur Referenz für spätere Zugriffe. Dieser Prozess ist in Anhang \ref{fig:SL-Basketcreation} verdeutlicht. Es sind keine Invarianten zu prüfen, außer dem korrekten Format der Empfangsdaten.

\comment{Grafiken in Anhang? Manche weglassen? Hier hinzufügen?}

\subsection{Abruf eines Baskets anhand der Basket-ID}

Anhand der Basket-ID kann nun der Warenkorb jederzeit durch den Touchpoint abgefragt werden. Die wichtigste Bedingung für diesen Anwendungsfall besagt, dass der Warenkorb stets mit aktuellen Daten befüllt sein muss. Dies stellt eine Herausforderung dar, da sich Preise und Artikeldetails mit dem Verlauf der Zeit ändern. Um das Problem möglichst performant zu lösen, werden die Informationen auf begrenzte Dauer zwischengespeichert. Dadurch wird nicht jedes Mal das externe System aufgerufen, sondern die Werte aus dem Cache geladen. Genaue Zeitspannen wurden durch die verantwortlichen Teams festgelegt. Dies bedeutet jedoch, dass die Software das Alter der im Warenkorb enthaltenen Informationen analysieren und gegebenenfalls aktualisieren muss. Auf Authentifizierung und Autorisierung wurde in dem POC und den Diagrammen verzichtet, da es sich rein um eine technische Funktion handelt und keine Relevanz für die Projektumsetzung besitzt. Es verbleiben Aufgaben, wie die Suche des Warenkorbs innerhalb der Datenbank, die De- und Serialisierung der Objekte und das Zurückgeben von Fehlern, falls der Warenkorb nicht gefunden werden konnte. Anhang \ref{fig:SL-Basketabruf} stellt das zugehörige Aktivitätsdiagramm für diesen Anwendungsfall dar.

\subsection{Stornierung eines offenen Baskets}

Der Warenkorb kann sich in verschiedenen Zuständen befinden. Hauptsächlich wird unterschieden zwischen 'Open', 'Freeze', 'Finalized' und 'Canceled'. Sollte beispielsweise ein Kunde beim Bezahlen an der Kasse im Markt nicht ausreichend Geld bei sich haben, muss der Warenkorb als 'Canceled' vermerkt werden. Die tatsächliche Löschung eines Baskets ist aus rechtlichen Gründen strengstens untersagt. Für diesen Prozess ist es notwendig, vorher zu prüfen, ob der Warenkorb sich im Zustand 'Open' befindet, da ein eingefrorener, abgeschlossener oder bereits stornierter Warenkorb zur Wahrung des Zustandsverlaufes nicht storniert werden kann. Dies stellt eine Invariante dar, welche in der Software sichergestellt werden muss. Im Diagramm in Anhang \ref{fig:SL-Basketstornierung} ist dieser Vorgang zusammengefasst abgebildet.

\subsection{Aktualisieren der Checkout Daten des Baskets}

Ein Warenkorb besitzt eine große Menge an Attributen. Einige dieser werden implizit durch einen Prozess innerhalb der Software gesetzt, andere durch Empfangen der Daten von einem externen System. Beim sogenannten 'Checkout-Prozess' werden Informationen vom Touchpoint an den Warenkorb gesendet, wie unter anderem Kundendaten, Zahlungsmethode und Zustellungsart. Da diese Daten innerhalb eines einzelnen Verfahrens durch das vorgelagerte System gesammelt werden, bietet es sich an, die korrespondierende Schnittstelle so zu designen, dass alle betroffenen Attribute gleichzeitig angepasst werden können. Eine Überprüfung der Daten erfolgt in diesem Schritt dabei nicht, mit der Ausnahme, dass die gewählte Zustellungsart, in dem Bounded-Context 'Fulfillment' genannt, für den ausgewählten Warenkorb und dessen Produkte überhaupt verfügbar sein muss. Zudem ist es notwendig eine Neuberechnung des Bezahlvorgangs durchzuführen, falls eine neue Zahlungsmethode hinzugefügt worden ist. Diese Bedingungen und der dazugehörige Prozess sind in Anhang \ref{fig:SL-Checkoutdata} veranschaulicht worden.

\subsection{Hinzufügen eines Produktes anhand einer Produkt-ID}

Der Warenkorb fungiert ebenfalls als ein Speicher einer Liste von Artikeln, sowie deren Quantität, Produktbeschreibung und ausgewählte Service bzw. Garantien. Der aufwändigste und deswegen in Anhang \ref{fig:SL-AddProduct} dargestellte Prozess ist hierbei das Hinzufügen eines neuen Produktes zum Basket. Dabei sendet der Client lediglich die zugehörige Produkt-ID, weswegen externe System von der Checkout-Software aufgerufen werden müssen. Dazu gehört die Product-API, welche alle notwendigen Produktdetails liefert. Der Artikelpreis selbst ist hierbei nicht in den Produktinformationen zu finden, da dieser von Markt zu Markt unterschiedlich sein kann. Daher wird eine weiterer API-Abfrage benötigt, welche zu der Produkt-ID und zugehörigen Outlet-ID den jetzigen Preis zurückschickt. Diese zwei Schnittstellen müssen ebenfalls bei der Aktualisierung des Warenkorbs in anderen Anwendungsfällen aufgerufen werden, sofern die zwischengespeicherten Werte im Cache nicht mehr gültig sind. Zusätzlich folgt eine Validierung des Warenkorbs auf verschiedene Parameter. Unter anderem darf die Gesamtanzahl der Artikel im Warenkorb keinen festen Wert überschreiten. Der aktualisierte Basket wird beim erfolgreichen Abschluss der Operation dem Touchpoint zurückgegeben.



\subsection{Hinzufügen einer Zahlungsmethode}

Eine weiter essentielle Funktion ist das Hinzufügen von Zahlungsmethoden, damit der Kauf erfolgreich initiiert werden kann. Da es sich nur um das ungeprüfte Anhängen der Bezahlinformationen handelt, müssen keine strengen Validierungen vorgenommen werden, weil diese Aufgabe durch ein externes System in einem späteren Schritt des Checkouts erledigt wird. Dennoch sind logische Überprüfungen durchzuführen, wie zum Beispiel, dass der Warenkorb nicht leer oder bereits bezahlt ist. Ebenfalls findet eine Neuberechnung aller Bezahlinformationen statt. Analog zu den vorgehenden Fällen wurde in Anhang \ref{fig:SL-PutBezahlmethode} designt.

\subsection{Initiierung des Bezahlprozesses und Einfrieren des Baskets}

Nachdem die Bearbeitung des Baskets abgeschlossen ist, kann der Bezahlprozess gestartet werden. Hierbei muss der Warenkorb einen konsistenten und validen Stand besitzen. Sollte dies der Fall sein, wird der Basket in den Status 'Freeze' gestellt und jegliche weitere Datenänderungen verhindert. Der Bezahlprozess wird von einer externen Software abgewickelt. Alleinig eine Referenz auf diesem Prozess wird im Warenkorb gespeichert. Eine vereinfachte Darstellung des Prozesses bietet Anhang \ref{fig:SL-InitPayment}

\subsection{Ausführung des Bezahlprozesses und Finalisierung des Baskets}

Als letzter, höchst relevanter Anwendungsfall befindet sich der Abschluss des Bezahlungsvorgangs, abgebildet in Anhang \ref{fig:SL-ExecPayment}. Die Checkout-Software dient hierbei als Proxy zwischen Touchpoint und Payment-API. Sofern die Bezahlung erfolgreich war, wird der Status des Baskets auf 'Finalized' gestellt. Zugleich wird eine Bestellung durch die Order-API angelegt und im Basket durch eine Referenz verlinkt. \\\\

Es existieren noch weiter simplere Prozesse, jedoch auf genaue Ausführung wurde verzichtet, um den Fokus der Arbeit beizubehalten. Durch die Anforderungen an der Checkout-Software kann auch bestimmt werden, welche Systeme als Kommunikationspartner benötigt werden. Dies ergib das Umfeld des Projekts. 

\subsection{Resultierende API-Schnittstellen aus den Anwendungsfällen}

Anhand dieser Anwendungsfälle wird es möglich eine klare Schnittstellendefinition für die Checkout-Applikation zu erstellen. Hierbei beinhaltet diese alle benötigten Operationen zum erfolgreichen Bewältigen der Anforderungen aus Sicht des Touchpoints. Die Kommunikation der Systeme geschieht über eine \acrshort{REST}-API und somit auf Basis des \acrshort{HTTP}-Protokolls. In Anhang \ref{fig:REST-API} sind alle relevanten Endpunkte enthalten, mitsamt ihrer HTTP-Methode, Parameter und gesendeten bzw. empfangenen Datensätze.

\section{Projektumfeld und technologische Vorschläge}

Die komplette Systemumgebung von MediaMarktSaturn ist eine komplexe Struktur mit zahlreichen Abhängigkeiten zwischen Teams und ihren betreuten Applikationen. Es ist unmöglich ein solches Konstrukt aufzubauen ohne die Kommunikation der einzelnen Systeme untereinander zu definieren. Als Leitfaden für dieses Projektumfeld dienen die Anwendungsfälle des vorgehenden Unterkapitels. In dem vereinfachten Checkout-Prozess werden sechs verschiedene Schnittstellen aufgerufen. Damit plötzliche Systemänderungen keine Auswirkung auf die Funktionsweise der abhängigen Clients haben, wird eine verpflichtende API-Vereinbarung beschlossen, welcher die benötigten Informationen, mögliche Fehlerfälle und die zurückgelieferten Daten festlegt. Der Proof-of-Concept orientiert sich an diese Vereinbarungen, erleichtert allerdings die Kommunikationsbedingungen, um unnötigen \Gls{Boilerplate}-Code zu unterdrücken. Die Abbildung \ref{fig:ContextDiagramm} stellt ein Context-Diagramm der Umgebung dar.


\begin{figure}[htbp]
	\centering
	\includesvg[inkscapelatex=false, width=0.8\textwidth]{svg/ContextDiagramm.svg}
	\caption{Context Diagramm der produktiven Checkout-Umgebung}
	\label{fig:ContextDiagramm}
\end{figure}

Zusätzlich bestehen noch firmen- bzw. teaminterne Vorbedingungen. Wo sinnvoll anwendbar, wird in der Firma Java als Entwicklungssprache angewandt. Über die letzten Jahre gewann Kotlin an Beliebtheit und wird seitdem ebenfalls in MediaMarktSaturn eingesetzt. Die aktuelle Live-Umgebung nutzt zu dem jetzigen Stand noch Java, jedoch werden Codeanpassungen zukünftig in Kotlin vorgenommen, um eine langsame Migration zu gewährleisten. Aus diesem Grund wird ebenfalls der Proof-of-Concept in Kotlin umgesetzt. Zudem ist die Technologie der systemübergreifenden Kommunikation auf REST-APIs festgelegt. Dies kommt mit einigen Einschränkungen und muss in der Entwicklung der primären und sekundären Adapter beachtet werden. Die Auswahl der Datenbank ist grundsätzlich nicht vorgegeben. Da die Applikation eine Vielzahl an Leseoperationen durchführt und somit einen hohen Nutzen aus der erhöhten Performance von No-SQL Datenbanken zieht, wurde die Benutzung einer MongoDB beschlossen.
