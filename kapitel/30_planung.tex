
%% PLANUNG %% 

\chapter{Planungs- und Analysephase}

Der erfolgreiche Abschluss eines Projektes mit Domain-Driven Design erfordert die sorgfältige Analyse der Domain und des Bounded-Contexts. Basierend auf diesen Erkenntnissen kann das Domain-Modell und die Ubiquitous Language vollständig definiert werden. Besonders ist der Aggregationsschnitt von den Anwendungsfällen abhängig \cite[S. 358]{Vernon.2015}. Aus diesen Gründen wird im folgenden Kapitel der Bounded-Context umfassend untersucht. Hierbei ist die Funktionalität eines Warenkorbs und des zugehörigen Datenmodells in dem Term 'Basket' zusammengefasst, um eine einheitliche Benamung innerhalb der Ubiquitous Language einzuhalten.

\section{Ausschlaggebende Anwendungsfallbeschreibungen}


Um den Kunden im Onlineshop oder den Mitarbeitern in den Märkten eine einwandfreie Benutzererfahrung zu gewährleisten, soll die Checkout-Software alle Prozesse, vom Erstellen eines Baskets bis hin zum Kaufabschluss, verwalten können. Zu Dokumentationszwecken ist es empfehlenswert die Anwendungsfälle in Diagrammen abzubilden. Zusätzlich werden dadurch eventuelle Unklarheiten geklärt, Bedingungen an die Datenstrukturen oder den Programmfluss aufgedeckt und eine natürliche Benutzung der Ubiquitous Language etabliert. Auf Basis dieser Anwendungsfälle ist es außerdem später möglich, Artefakte des Domain-Driven Designs leichter zu definieren. Vor allem die entscheidenden Invarianten bilden sich heraus und das Datenmodell kann klarer in Aggregates unterteilt werden. Die wichtigsten Anwendungsfälle für den Proof-of-Concept sind in diesem Kapitel vereinfacht beschrieben. Bei der Reduzierung der Prozesse ist zu beachten, dass Bedingungen zwischen Datenstrukturen weiterhin unverändert bleiben, damit die möglichen Aggregationsschnitte nicht von den realisierbaren Varianten der Produktivanwendung abweichen. Dieser Abschnitt dient somit als Grundlage für das Design der Software und wird in späteren Kapiteln referenziert. Die folgenden Prozesse wurden in Zusammenarbeit mit den Teams des Onlineshops, dem Checkout-Team und zuständigen \Gls{Stakeholder}n erarbeitet. Als Darstellungsmethode wurde sich auf Aktivitätsdiagramme geeinigt, damit die Interaktionen zwischen den Systemen ebenfalls aufgezeigt werden können. Die Clients der Checkout-Software, wie der Onlineshop oder die Handy-App, sind unter dem Begriff 'Touchpoint' zusammengefasst. Falls die Graphen keine Relevanz für das leserliche Verständnis der Arbeit besitzen, sind sie dem Anhang hinzugefügt worden.

\subsection{Erstellung eines neuen, leeren Baskets}

Die Erzeugung eines Baskets kann aus verschiedenen Gründen geschehen, beispielsweise wenn ein nicht eingeloggter Kunde zum ersten Mal den Onlineshop aufruft oder ein Mitarbeiter an einer physikalischen Kasse im Markt einen Kauf abschließt. Der Erstellungsprozess besteht hauptsächlich aus dem Empfangen der Kundendaten, die Identifikation des zugehörigen Marktes mithilfe der Outlet-ID und dem permanenten Speichern des neuen Baskets. Es sind keine Invarianten zu prüfen, außer dem korrekten Format der übertragenen Nutzdaten. Dem Touchpoint wird das komplette Basket-Objekt zurückgegeben inklusive einer Basket-ID zur Referenz für spätere Zugriffe. Dieser Prozess ist in Anhang \ref{fig:SL-Basketcreation} verdeutlicht. 

\pagebreak

\subsection{Abruf eines Baskets anhand der Basket-ID}

Anhand einer ID kann ein Basket jederzeit durch den Touchpoint abgerufen werden. Die wichtigste Bedingung für diesen Anwendungsfall besagt, dass angefragte Ressourcen stets mit aktuellen Daten befüllt sein müssen. Dies stellt eine Herausforderung dar, da sich Preise und Artikeldetails mit dem Verlauf der Zeit ändern. Um das Problem möglichst performant zu lösen, werden die Informationen auf begrenzte Dauer in einem Cache zwischengespeichert. Dadurch können Aufrufe externer Systeme eingespart werden. Die genaue Speicherdauer wurde durch das verantwortliche Team festgelegt. Dies bedeutet jedoch, dass das Alter der Informationen nachvollziehbar sein muss, weshalb der Zeitstempel im Datenmodell hinterlegt wird. Auf Authentifizierung und Autorisierung wurde in dem Proof-of-Concept und den Diagrammen verzichtet, da es sich um eine rein technische Funktion handelt und keine Relevanz für die Projektumsetzung besitzt. Es verbleiben Aufgaben, wie die Suche des Baskets innerhalb der Datenbank, die De- und Serialisierung der Objekte und das Zurückgeben von Fehlermeldungen, falls beispielsweise Ressourcen nicht gefunden werden konnten. Abbildung \ref{fig:SL-Basketabruf} zeigt das zugehörige Aktivitätsdiagramm.

\begin{figure}[H]
	\centering
	\includesvg[inkscapelatex=false, width=\textwidth]{svg/AD Basketabruf.svg}
	\caption{Aktivitätsdiagramm für den Abruf eines Baskets}
	\label{fig:SL-Basketabruf}
\end{figure}

\subsection{Stornierung eines offenen Baskets}

Der Basket kann sich in verschiedenen Zuständen befinden. Es wird unterschieden zwischen 'Open', 'Frozen', 'Finalized' und 'Canceled'. Sollte beispielsweise ein Kunde beim Bezahlen an der Kasse im Markt nicht ausreichend Geld bei sich haben, muss der Basket als 'Canceled' vermerkt werden. Für diesen Prozess ist es notwendig, vorher zu prüfen, ob der Zustand sich in 'Open' befindet, da ein eingefrorener, abgeschlossener oder bereits stornierter Basket zur Wahrung des Zustandsverlaufes nicht storniert werden kann. Dies stellt eine Invariante dar, welche in der Software sichergestellt werden muss. Im Diagramm in Anhang \ref{fig:SL-Basketstornierung} ist der Vorgang zusammenfassend abgebildet. Die tatsächliche Löschung eines Baskets ist aus rechtlichen Gründen strengstens untersagt. 

\pagebreak


\subsection{Hinzufügen eines Produktes anhand einer Produkt-ID}

Der Basket fungiert ebenfalls als ein Speicher einer Liste von Artikeln, sowie deren Quantität, Produktbeschreibung und ausgewählten Services bzw. Garantien. Der aufwändigste und deswegen in Abbildung \ref{fig:SL-AddProduct} dargestellte Prozess ist hierbei das Hinzufügen eines neuen Produktes zum Basket. Dabei sendet der Client lediglich die zugehörige Produkt-ID, weswegen externe Systeme von der Checkout-Software aufgerufen werden müssen. Dazu gehört die Product-API, welche alle notwendigen Produktdetails liefert. Der Artikelpreis selbst ist hierbei nicht in den Produktinformationen zu finden, da dieser von Markt zu Markt unterschiedlich sein kann. Daher wird eine weitere API-Abfrage benötigt, welche zu einer Produkt-ID und Outlet-ID den zugehörigen, aktuellen Preis zurückschickt. Diese zwei Schnittstellen müssen ebenfalls in anderen Anwendungsfällen aufgerufen werden, sofern die zwischengespeicherten Preis- bzw. Artikelinformationen im Cache nicht mehr gültig sind. Zusätzlich folgt eine Validierung des Datenmodells auf verschiedene Parameter. Unter anderem darf die Gesamtanzahl der enthaltenen Artikel keinen festen Wert überschreiten. Der aktualisierte Basket wird beim erfolgreichen Abschluss der Operation dem Touchpoint zurückgegeben.

\begin{figure}[H]
	\centering
	\includesvg[inkscapelatex=false, width=\textwidth]{svg/AD AddProduct.svg}
	\caption{Aktivitätsdiagramm für das Hinzufügen eines Produktes }
	\label{fig:SL-AddProduct}
\end{figure}

\subsection{Hinzufügen einer Zahlungsmethode}

Eine weitere essentielle Funktion ist das Hinzufügen von Zahlungsmethoden, damit der Kauf erfolgreich initiiert werden kann. Da es sich nur um das ungeprüfte Anhängen der Bezahlinformationen handelt, müssen keine strengen Validierungen vorgenommen werden, weil diese Aufgabe durch ein externes System in einem späteren Schritt des Checkouts erledigt wird. Dennoch sind logische Überprüfungen durchzuführen, wie zum Beispiel, dass der Basket nicht leer oder bereits bezahlt ist. Ebenfalls findet eine Neuberechnung aller Bezahlinformationen statt. Analog zu den vorgehenden Fällen wurde ein Aktivitätsdiagramm in Anhang \ref{fig:SL-PutBezahlmethode} designt.

\pagebreak

\subsection{Aktualisieren der Checkout Daten des Baskets}

Ein Basket besitzt eine große Menge an Attributen. Einige dieser werden implizit durch einen Prozess innerhalb der Software gesetzt, andere durch Empfangen der Daten von einem externen System. Beim sogenannten 'Checkout-Prozess' werden Informationen, wie Kundendaten, Zahlungsmethode und Zustellungsart, von den Touchpoints an die API gesendet. Da die Daten innerhalb eines einzelnen Verfahrens durch das vorgelagerte System gesammelt werden, bietet es sich an, die korrespondierende Schnittstelle so zu designen, dass alle betroffenen Attribute gleichzeitig angepasst werden können. Eine Überprüfung der Daten erfolgt in diesem Schritt nicht, mit der Ausnahme, dass die gewählte Zustellungsart, in dem Bounded-Context 'Fulfillment' genannt, für den ausgewählten Basket verfügbar sein muss. Zudem ist es notwendig eine Neuberechnung der Zahlungsmethoden durchzuführen, falls eine neue Zahlart hinterlegt worden ist. Diese Bedingungen und der dazugehörige Prozess sind in Anhang \ref{fig:SL-Checkoutdata} veranschaulicht worden.


\subsection{Initiierung des Bezahlprozesses und Einfrieren des Baskets}

Nachdem die Bearbeitung des Baskets abgeschlossen ist, kann der Bezahlprozess gestartet werden. Hierbei muss das Datenmodell einen konsistenten und validen Stand besitzen. Sollte dies der Fall sein, wird der Basket in den Status 'Freeze' gestellt und jegliche weitere Datenänderungen verhindert. Der Bezahlprozess wird von einer externen Software abgewickelt und durch eine Referenz im Basket verlinkt. Eine vereinfachte Darstellung des Prozesses bietet Abbildung \ref{fig:SL-InitPayment}.

\begin{figure}[H]
	\centering
	\includesvg[inkscapelatex=false, width=\textwidth]{svg/AD InitPayment.svg}
	\caption{Aktivitätsdiagramm für das Initiieren des Bezahlvorgangs }
	\label{fig:SL-InitPayment}
\end{figure}

\pagebreak

\subsection{Ausführung des Bezahlprozesses und Finalisierung des Baskets}

Als letzter, höchst relevanter Anwendungsfall gilt der Abschluss des Bezahlvorgangs, visualisiert in Abbildung \ref{fig:SL-ExecPayment}. Die Checkout-Software dient hierbei als Proxy zwischen den Touchpoints und der Payment-API. Sofern die Bezahlung erfolgreich war, wird der Status des Baskets auf 'Finalized' gestellt. Zugleich wird eine Bestellung durch die Order-API angelegt und im Basket durch eine Referenz verlinkt.

\begin{figure}[H]
	\centering
	\includesvg[inkscapelatex=false, width=\textwidth]{svg/AD ExecPayment.svg}
	\caption{Aktivitätsdiagramm für das Ausführen des Bezahlvorgangs }
	\label{fig:SL-ExecPayment}
\end{figure}

\subsection{Aus Anwendungsfällen resultierende API-Schnittstellen }

Anhand der Anwendungsfälle ist es möglich eine klare Schnittstellendefinition für die Checkout-Applikation zu erstellen. Hierbei beinhaltet diese alle benötigten Operationen zum erfolgreichen Bewältigen der Anforderungen aus Sicht der Touchpoints. Die Kommunikation zwischen den Systemen geschieht über eine \acrshort{REST}-API und somit auf Basis des \acrshort{HTTP}-Protokolls. In Anhang \ref{fig:REST-API} sind alle Endpunkte enthalten, mitsamt ihrer HTTP-Methoden, Parametern und gesendeten bzw. empfangenen Datenstrukturen.

\pagebreak

\section{Projektumfeld und technologische Vorschläge}

Die komplette Systemumgebung von MediaMarktSaturn ist eine komplexe Architektur mit zahlreichen Abhängigkeiten zwischen Teams und ihren betreuten Applikationen. Es ist unmöglich ein solches Konstrukt aufzubauen ohne die Kommunikation der einzelnen Systeme untereinander zu definieren. Als Leitfaden für das Projektumfeld dienen die Anwendungsfälle des vorgehenden Unterkapitels. In dem vereinfachten Checkout-Prozess werden sechs verschiedene Schnittstellen aufgerufen. Damit plötzliche Systemänderungen keine Auswirkung auf die Funktionsweise der abhängigen Clients haben, wird eine verpflichtende API-Vereinbarung beschlossen, welche die benötigten Informationen, mögliche Fehlerfälle und die zurückgelieferten Daten festlegt. Der Proof-of-Concept orientiert sich an diesen Vereinbarungen, erleichtert allerdings die Kommunikationsbedingungen, um unnötigen \emph{\Gls{Boilerplate-Code}} zu unterdrücken. Die Abbildung \ref{fig:ContextDiagramm} stellt ein Context-Diagramm der Umgebung dar. 

\begin{figure}[htbp]
	\vspace{0.5cm}
	\centering
	\includesvg[inkscapelatex=false, width=0.8\textwidth]{svg/ContextDiagramm.svg}
	\caption{Context Diagramm der produktiven Checkout-Umgebung}
	\label{fig:ContextDiagramm}
	\vspace{0.5cm}
\end{figure}

Zusätzlich bestehen noch firmen- bzw. teaminterne Vorbedingungen. Wo sinnvoll anwendbar, wird in der Firma Java als Entwicklungssprache angewandt. Über die letzten Jahre gewann Kotlin an Beliebtheit und wird seitdem ebenfalls bei MediaMarktSaturn eingesetzt. Die aktuelle Live-Umgebung nutzt zu dem jetzigen Stand noch Java, jedoch werden Codeanpassungen zukünftig in Kotlin vorgenommen, um eine langsame Migration zu gewährleisten. Aus diesem Grund wird ebenfalls der Proof-of-Concept in Kotlin umgesetzt. Zudem ist die Technologie für eine systemübergreifende Kommunikation auf REST-APIs festgelegt. Dies kommt mit einigen Einschränkungen und muss in der Entwicklung der primären und sekundären Adapter beachtet werden. Die Auswahl der Datenbank ist grundsätzlich nicht vorgegeben. In einem späteren Kapitel wird die Verwendung einer MongoDB für das Projekt begründet.
