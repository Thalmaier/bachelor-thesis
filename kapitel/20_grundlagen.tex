
%% EINLEITUNG %% 

\chapter{Grundlagen}

% Solid erklären? Oder ganz auslassen

Zur erfolgreichen Durchführung dieses Projekts werden Kernkompetenzen der Softwareentwicklung vorausgesetzt. Diese beschäftigen sich weitestgehend mit Softwaredesign und Architekturstilen. Gängige Designprinzipien sollen sicherstellen, dass die Software positive Qualitätsmerkmale widerspiegelt und von diesen profitieren kann. Dadurch wird die Zukunftssicherheit sichergestellt, sodass auch bei Expansion der Software diese testbar, anpassbar und fehlerfrei agiert. Das weitverbreitete Akronym SOLID steht hierbei für eine Ansammlung an fünf solcher Designprinzipien, namentlich Single-Responsibility-Prinzip (SRP), Open-Closed-Prinzip (OCP), Liskovsches Substitutionsprinzip (LSP), Interface-Segregation-Prinzip (ISP) und das Dependency-Inversion-Prinzip (DIP). Architekturen und Kompositionen können anhand dieser bewertet und verglichen werden. Diese Vorgehensweise wurde verwendet, um die nachfolgenden Architekturstile zu vergleichen und bewerten. 

\section{Architekturmuster}

% Definition, Auswahl der Architektur, konkrete Besipiele
% MVC ist Schichtenarchitektur, daher nicht erwähnen?

Eine Softwarearchitektur beschreibt die grundlegende Struktur der darüberlegenden Module und ihre Relationen zueinander. Die Wahl der verwendeten Architektur beeinflusst somit die komplette Applikation und ihre Qualitätsmerkmale. Die zu bevorzugende Struktur ist stark abhängig von den Anwendungsfall und existierenden Anforderungen. In diesem Projekt soll ein Backend-Service erstellt werden, welcher mit den vorgelagerten Systemen über HTTP und REST kommuniziert. Dadurch wird die Auswahl der optimalen Architektur beschränkt, da beispielsweise Designmuster, wie Model-View-Controller oder Peer-To-Peer für dieses Projektumfeld generell keine Anwendung finden.  Ein Pipe-Filter Aufbau ist geeignet für die Verarbeitung von einer Vielzahl an Daten. Jedoch ist das Abbilden von Entscheidungsstränge und Businessrichtlinien nur umständlich zu verwirklichen. Etablierte Architekturen für Backend-Software, welche die Businessprozesse als Kern der Applikation halten, müssen hingegen genauer untersucht werden. Die Schichtenarchitektur und die Hexagonale Architektur erfüllen hierbei diese Bedingungen und bieten ein solides Fundament für dieses Projekt. Trotz der ähnlichen Ziele der Architekturen unterscheidet sich ihr Aufbau stark voneinander. In den folgenden Abschnitt werden beide Stile untersucht und bewertet anhand ihrer Tauglichkeit für eine Checkout-Software. Diese Bewertung beinhaltet ebenfalls die native erhaltene Unterstützung durch die Architekturen zur Umsetzung von Designprinzipien, sodass die generelle Softwarequalität gewährleistet werden kann. 

\subsection{Schichtenarchitektur}

% SOLID weiter ausführen?
% Weiterhin gleiche Softwarequalität möglich auch mit Schichtenarchitektur

Durch die Einteilung der Softwarekomponenten in einzelne Schichten wird eine fundamentale Trennung der Verantwortlichkeiten und ihre Domänen erzwungen. Die Anzahl der Schichten kann je nach Anwendungsfall variieren, liegt jedoch meist zwischen drei und vier Ebenen. Die meistverbreitete Variante beinhaltet die Präsentations-, Business- und Datenzugriffsschicht. Der Kontrollfluss der Anwendung fließt hierbei stets von einer höheren Schicht in eine tiefere gelegene oder innerhalb einer Ebene zwischen einzelnen Komponenten. Ohne eine konkrete Umkehrung der Abhängigkeiten ist der Abhängigkeitsgraph gleichgerichtet zum Kontrollflussgraph. Hierbei dient Abbildung \ref{fig:Schichtenarchitektur} als eine beispielhafte Darstellung einer solchen Architektur. 

\begin{figure}[htbp]
	\centering
	\large
	\includesvg[width=0.5\textwidth]{svg/Schichtenarchitektur.svg}
	\caption{Beispielhafte Darstellung einer Drei-Schichtenarchitektur}
	\label{fig:Schichtenarchitektur}
\end{figure}

Das Ziel einer Schichtenarchitektur ist die Entkopplung der einzelnen Schichten voneinander und das Erreichen von geringen Abhängigkeiten zwischen den Komponenten. Dadurch sollen Qualitätseigenschaften wie Testbarkeit, Erweiterbarkeit und Flexibilität erhöht werden. Dank dem simplen Aufbau gewann dieser Architekturstil an großer Beliebtheit, jedoch aufgrund der fehlenden Restriktionen erhalten Entwicklern nur geringe Beihilfe zur korrekten Umsetzung des Softwaredesigns. 

Beispielsweise sind die SOLID-Prinzipien nicht oder nur minimal im Grundaufbau verankert. Das Single-Responsibility-Prinzip wird durch die Schichteneinteilung unterstützt, da Komponente zum Beispiel nicht den Zugriff auf die Datenbank und gleichzeitig Businesslogik beinhalten kann. Nichtsdestotrotz ist eine vertikale Trennung innerhalb einer Schicht nicht gegeben, daher können weiterhin Komponenten mehrere, konzeptionell verschiedene Aufgaben entgegen des SRPs erfüllen. Um die einzelnen Schichten zu entkoppelt, kann die Kommunikation zwischen den Ebenen durch Schnittstellen geschehen. Das Open-Closed-Prinzip soll hierbei helfen, dass Änderungen an den Schnittstellen und ihren Implementierungen die Funktionsweise, worauf tieferliegende Schichten basieren, nicht brechen. Die konzeptionelle Zuteilung dieser Interfaces ist entscheidend, um eine korrekte Anwendung des Dependency-Inversion-Prinzips zu gewährleisten. Meist wird bei sogenannten CRUD-Applikationen eine Schichtenarchitektur verwendet. CRUD steht im Softwarekontext für '\textbf{Cr}eate \textbf{U}pdate \textbf{D}elete', somit sind Anwendungen gemeint, welche Daten mit geringer bis keiner Geschäftslogik erzeugen, bearbeiten und löschen. Im Kern einer solchen Software liegen die Daten selbst, dabei werden Module und die umliegende Architektur angepasst, um die Datenverarbeitung zu vereinfachen. Dadurch richten sich oft die Abhängigkeiten in einer Schichtenarchitektur von der Businessschicht zur Datenzugriffsschicht. Bei einer Anwendung, welche der zentralen Teil die Businesslogik ist, sollte hingegen die Abhängigkeiten stets zur Businessschicht fließen. Daher muss während des Entwicklungsprozesses stets die konkrete Einhaltung des DIP beachtet werden, da entgegen der intuitiven Denkweise einer Schichtenarchitektur gearbeitet werden muss. Folglich bietet dieser Architekturansatz durch seine Simplizität beiderseits Vorteile und Nachteile. 


\subsection{Hexagonale Architektur}

%Dependency Injection?

Durch weitere architektonische Einschränkungen können Entwickler zu besseren Softwaredesign gezwungen werden, ohne dabei die Implementierungsmöglichkeiten einzuengen. Dieser Denkansatz wird in der von Alistair Cockburn geprägten Hexagonalen Architektur angewandt, indem eine klare Struktur der Softwarekomposition vorgegeben wird. Hierbei existieren drei Bereiche in denen die Komponenten angesiedelt sein können, namentlich die primären Adapter, der Applikationskern und die sekundären Adapter. 

Die gesamte Kommunikation zwischen den Adaptern und dem Applikationskern findet über sogenannte Ports statt. Diese dienen als Abstraktionsschicht und sorgen für Stabilität und Schutz vor Codeänderungen. Realisiert werden Ports meist durch Interfaces, welche hierarchisch dem Kern zugeteilt und deren Design durch diesen maßgeblich bestimmt. Somit erfolgt eine erzwungene Einhaltung des \emph{Dependency-Inversion-Prinzips}, wodurch die Applikationslogik von externen Systemen und deren konkreten Implementierungen entkoppelt wird. Dies erhöht drastisch Qualitätsmerkmale der Anwendung, wie geringe Kopplung zwischen Komponenten, Wiederverwendbarkeit und Testbarkeit. 

Unter den Adaptern fallen jegliche Komponenten, welche als Schnittstellen zwischen externen Systemen und der Geschäftslogik dienen. Dabei sind die primären Adapter jeglicher Code, welche durch externe Systeme angestoßen wird und hierbei den Steuerfluss in den Applikationskern trägt. Diese externen Systemen, wie Benutzerinterfaces, Test-Engines und Kommandokonsolen, können beispielsweise einen Methodenaufruf initiieren, welcher durch die primären Adapter verarbeitet werden. Andererseits bilden alle Komponenten, welche den Steuerfluss von dem Applikationskern zu externen Systemen tragen, die sekundären Adapter. Hierbei entsteht der Impuls im Vergleich zu den primären Adaptern nicht außerhalb der Applikation sondern innerhalb. Die, von den sekundären Adaptern angesprochenen Systemen, können beispielsweise Datenbanken, Massage-Broker und jegliche im Prozess tieferliegende Software sein. 

Letztendlich werden alle übrigen Module im Applikationskern erschlossen. Diese beinhalten Businesslogik und sind komplett von äußeren Einflussfaktoren entkoppelt. Der beschriebene Aufbau wird in Grafik \ref{fig:HexagonaleArchitektur} veranschaulicht.

\begin{figure}[htbp]
	\centering
	\includesvg[width=0.65\textwidth]{svg/HexagonaleArchitektur.svg}
	\caption{Grundstruktur einer Hexagonalen Architektur}
	\label{fig:HexagonaleArchitektur}
\end{figure}

Das Speichern von Daten ist ein simpler Anwendungsfall, welcher im folgenden beispielhaft in einer hexagonalen Applikation dargestellt wird. Die Daten, welche von einer Website an die Anwendung geschickt werden, initiieren den Steuerfluss in einem sogenannten Controller. Dieser ist den primären Adaptern zugeteilt und erledigt Aufgaben, wie Authentifizierung, Datenumwandlung und erste Fehlerbehandlungen. Über einen entsprechenden Port wird der Applikationskern mit den übergebenen Daten angesprochen. Innerhalb werden alle business-relevanten Aufgaben erfüllt. Darunter fallen das logische Überprüfen der Daten anhand von Businessrichtlinien, Erstellen neuer Daten und Steuerung des Entscheidungsflusses. In diesem Anwendungsfall sollen die Daten in einer Datenbank abgespeichert werden. Dementsprechend wird aus dem Anwendungskern über einen Port ein sekundäre Adapter aufgerufen, welcher für das Speicher von diesen Daten in einer Datenbank zuständig ist.

% Weiter ausführen?

Durch diesen Aufbau wird eine, im Vergleich zur Schichtenarchitektur, strengere konzeptionelle Trennung der Verantwortlichkeiten erzwungen. Dies wirkt sich positiv auf die Einhaltung des \emph{Single-Responsibility-Prinzip} aus. Zusätzlich wird die Anwendung des \emph{Open-Closed-Prinzips} und \emph{Interface-Segregation-Prinzips} erleichtert, durch die Einführung von Ports zwischen den Applikationskern und den, für das business-irrelevanten, Komponenten. Für erweiterbare Software ist das \emph{Dependency-Inversion-Prinzip} von großer Bedeutung, da viele der vorherigen genannten Qualitätsmerkmalen beeinflusst 





\section{Domain-Driven Design}

Bei der Entwicklung von Software, welche mehr als triviale Anwendungsfälle einer CRUD-Anwendung erfüllen soll, besteht stets die Gefahr bei steigender Anzahl von Anforderungen und Änderungen zu einem sogenannten 'Big Ball of Mud' zu {\color{red} degradieren}. Die bestehende Architektur wird undurchschaubar, die Entstehungschancen für Bugs steigen und Businessanforderungen finden sich überall verteilt in der Anwendung. Somit kann die Wartbarkeit der Software nicht mehr gewährleistet werden und ihre Langlebigkeit ist stark eingeschränkt. Die oben analysierten Architekturstile können bei strikter Einhaltung dieses Risiko einschränken, jedoch bestimmen sie nur begrenzt wie das zugrundeliegende Datenmodell und die damit verbundenen Komponente designt werden sollen. In dem Buch \citetitle{Evans.2011} hat Eric Evans im Jahre 2003 zu diesem Zweck Domain-Driven Design entwickelt. Grundlegend wird durch diese Herangehensweise die Businessprozesse in den Vordergrund gerückt, der Problemraum in Domains eingeteilt und Richtlinien für das Design von dem Domainmodell festgelegt. Domain-Driven Design, kurz \emph{DDD}, ist nicht gebunden an die darunterliegende Architektur oder verwendeten Technologien und folglich an verschiedenste Einsatzgebiete anpassbar.

Bevor die Bestandteile von DDD bestimmt werden können, sollte zu Beginn eine ausführliche Umfeldanalyse durchgeführt werden, um festzulegen welche Verantwortungen in den zu bestimmenden Bereich fallen. Somit wird unser Problemraum als eine \emph{Domain} aufgespannt. Der Domainschnitt ist hierbei entscheidend, da basierend auf der Domain die dazugehörigen \emph{Subdomains} und ihre \emph{Bounded Contexts} bestimmt werden. Eine Subdomain bündelt die Verantwortlichkeiten und zugehörigen Anwendungsfälle in eine spezifischeren Bereich der Domain. Zur Bestimmung der Subdomains wird der Problemraum stets aus Businesssicht betrachtet und technische Aspekte werden vernachlässigt. Sollte die Domain zu groß geschnitten sein, sind dementsprechend die Subdomains ebenfalls zu umfangreich. Dadurch ist die Kohäsion der Software gefährdet und führt über den Lauf der Entwicklungsphase zu architektonischen Konflikten. Sollte eine Subdomain multiple Verantwortlichkeiten tragen, kann diese Subdomain weiter in kleinere Subdomains eingeteilt werden. Für einen Domain-Driven Ansatz ist es entscheidend die Definitionsphase gewissenhaft durchzuführen, damit eine stabile Grundlage für die Entwicklung geboten werden kann. 

Als Ausgangspunkt für die Bestimmung der Lösungsebene, werden die Subdomains in sogenannte Bounded-Contexts eingeteilt. Ein Bounded-Context kann eine oder mehrere Subdomains umfassen und bündelt ihre zugehörigen Aufgabengebiete. Wie es in der Praxis häufig der Fall ist, können Subdomains und Bounded-Context durchaus identisch sein. In jedem Bereich sollte nur ein Team agieren, um Konflikte zu vermeiden. Andernfalls kann dies ein Indiz sein, dass die Subdomains zu groß geschnitten worden sind. Jeder Bounded-Context besitzt zudem eine zugehörige Ubiquitous Language. Die Festlegung der \emph{Ubiquitous Language} stellt einen wichtigen Schritt in deinem Domain-Driven Ansatz dar. Diese definiert die Bedeutung von Begriffen, welche durch die Stakeholder und das Business verwendet werden, eindeutig. Dadurch können Missverständnisse in der Kommunikation zwischen dem Business und den Entwicklern vorgebeugt und eventuelle Inkonsistenzen aufgedeckt werden. Der größte Vorteile ergibt sich allerdings, sobald auch das Datenmodell diese Sprache widerspiegelt. Entitäten können Nomen darstellen, Funktionen können Verben realisieren und Aktionen können als Event verwirklicht werden. Somit sind Businessprozesse auch im Quelltext wiederzufinden. Folglich steigert dies die Verständlichkeit und Wartbarkeit der Software. Zudem lassen sich Testfälle und Anwendungsfälle leichter definieren und umsetzten. Wichtig ist, dass diese Sprache nur innerhalb eines Bounded-Context gültig ist. Beispielhaft kann der Begriff 'Kunde' in einem Onlineshop einen zivilen Endkunden, jedoch im Wareneingang eine Lieferfirma beschreiben. Daher ist bei der Kommunikation zwischen Teams unterschiedlicher Subdomains zu beachten, dass Begriffe eventuell unterschiedliche Bedeutung besitzen. 

Die  Domains, Subdomains, Bounded-Contexts und ihre Kommunikation zueinander wird durch eine Context-Map dargestellt. Diese stellt ein wichtiges Artefakt der Definitionsphase dar und kann als Tool zur Bestimmung von Verantwortlichkeiten und Einteilung neuer Anforderungen in die Domains benutzt werden. Sollte eine eindeutige Zuteilung nicht möglich sein, spricht dies für eine Entstehung eines neuen Bounded-Contexts und eventuell einer neuen Subdomain. Sowie eine Software Anpassungen erlebt, entwickelt sich die Context-Map ebenfalls stetig weiter. 

%TODO: Beispiels Context-Map
\begin{figure}[htbp]
	\centering
	\includesvg[width=0.65\textwidth]{svg/CHANGE-Context-Map-Example.svg}
	\caption{\color{red} Beispiel einer Context-Map}
	\label{fig:Context-Map-Example}
\end{figure}

Im Zentrum von DDD steht das Domain-Modell, welches die Kenntnisse über den Bounded-Context darstellt. Es umfasst sowohl die Datenhaltung als auch das zugehörige Verhalten, wie zum Beispiel die Erstellung von Objekten oder ihre dauerhafte Speicherung. Für diesen Zweck existieren in Domain-Driven Design mehrere Objektgruppierungen, welche anhand ihrer Verantwortlichkeiten zugeordnet werden. Die Gruppen bestehen unter anderem aus:

\begin{itemize}[]
	\item \textbf{Wertobjekte: } {Zusammengehörige Daten, welche durch ihre konkreten Werte identifizierbar sind, werden durch Wertobjekte modelliert. Somit gelten Objekte mit der gleichen Wertbelegung als identisch. Aus Gründen der Wiederverwendbarkeit und zur Unterdrückung von unerwünschten Seiteneffekten gilt es als positives Designmuster Werteobjekte immutable zu gestalten.}
	\item \textbf{Entitäten: } {Im Gegenzug zu Wertobjekten sind Entitäten nicht durch ihre Werte identifizierbar sondern behalten in ihren Lebenszyklus die gleiche Identität bei. Somit sind zwei Entitäten mit gleichen Werten nicht identisch. Aufgrund dieser Eigenschaften werden Entitäten meist benutzt, um Daten in einer Datenbank zu persistieren und nach diesen zu suchen.}
	\item \textbf{Aggregate: } {Um Datenänderungen durchzuführen wird ein Zusammenschluss aus Entitäten und Wertobjekten benötigt, um die {\color{red} transaktionale Integrität} der Daten zu bewahren. Von außen darf ein Aggregat nur durch das sogenannte Aggregate Root referenzieren. Somit gilt das Aggregat Root als Schnittstelle zwischen den externen Komponenten und den inneren Daten bzw. Funktionen. Aufgrund dessen muss das Wurzelobjekt eine Entität darstellen, um eindeutig in der Datenbank referenziert zu werden. Innerhalb eines Aggregates gilt, dass Anforderungen bzw. Invarianten an die enthaltenen Objekte vor und nach einer Transaktion erfüllt sein müssen.}
	\item \textbf{Domänenservice: } {Sofern Funktionalitäten innerhalb der Domäne nicht eindeutig einer oder mehreren Entität bzw. Wertobjekt zugewiesen werden können, werden konzeptionell zusammenhängende Aufgaben in einem Domänenservice gebündelt. Um Seiteneffekte durch Zustandsänderungen zu vermeiden halten Service allgemein keinen eigenen Zustand.}
	\item \textbf{Applikationsservice: } {Ähnlich zu den Domänenservice sind Applikationsservice zur zustandslosen Bereitstellung von Funktionen zuständig. Hierbei ist das Unterscheidungsmerkmal, dass sie kein Domänenwissen besitzen dürfen.} %TODO: Replace "Verhalten"
	\item \textbf{Fabriken: } {Die wiederholten Erstellung von komplexen Objekten kann in eine Fabrikklasse ausgelagert werden, um eine erhöhte Wiederverwendbarkeit zu erreichen. }
	\item \textbf{Repositories: } {Der Datenzugriff mittels einer Datenbank wird durch ein Repository ermöglicht. Dadurch werden die konzeptionelle Abhängigkeiten zur Datenbank von der Domäne getrennt. Daher sollte generell die Kommunikation zu Repositories über ein fest definiertes Interface geschehen.}
\end{itemize}

%TODO: Above klingt sehr stark nach Wiki: https://de.wikipedia.org/wiki/Domain-driven_Design

Zusätzlich zum Design des Domain-Modells muss innerhalb eines Bounded-Contexts die grundlegende Architektur durch das zugehörige Team bestimmt werden. Je nach Sachverhalt des jeweiligen Kontexts kann sich diese stark von zwischen Bounded-Contexts unterscheiden. Beliebte Modellierungs- und Designstile in Verbindung mit DDD sind unter anderem Microservices, CQRS, Event-Driven Design, Schichtenarchitektur und Hexagonale Architektur. In den vorhergehenden Unterkapiteln wurden bereits die Vorzüge und Nachteile der zwei zuletzt genannten Architekturen erläutert. Auf Basis dieser Analyse wird generell für komplexere Software eine Hexagonale Architektur bevorzugt. Zudem verfolgen Domain-Driven Design und Hexagonale Architektur ähnliche Ziele, wodurch die Software natürlich an Kohäsion und Stabilität gewinnt. Im Zentrum der beiden steht das Domain-Modell, welches ohne Abhängigkeiten zu externen Modulen arbeitet. Primäre und Sekundäre Adapter sind hierzu technisch notwendige Komponente, welche durch fest definierte Ports auf den Applikationskern zugreifen können. 

%TODO: Why Hexagonal mit DDD ausführlicher

%TODO: Abschluss


















































